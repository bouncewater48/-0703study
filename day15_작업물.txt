day_작업물 (java 13일차)
복습 -> 접근제한자 -> 캐스팅 -> 추상클래스

==========================================================================

package accessmodifier01;

//1번 : 접근제한자
public class AccessTarget {

// 생성자
   // 기본생성자
   public AccessTarget() {
      System.out.println("public 생성자");
   }

   protected AccessTarget(String str) {
      System.out.println("protected 생성자 : " + str);
   }

   AccessTarget(int num) {
      System.out.println("default 생성자 : " + num);
   }

   private AccessTarget(double num) {
      System.out.println("private 생성자 : " + num);
   }

   // 메소드
   public void publicMethod() {
      System.out.println("public Method");
   }

   protected void protectedMethod() {
      System.out.println("protected Method");
   }

   void defaultMethod() {
      System.out.println("default Method");
   }

   private void privateMethod() {
      System.out.println("private Method");
   }

}

==========================================================================

package accessmodifier01;
// 1번 : 접근제한자
public class SameMain {
	public static void main(String[] args) {
		System.out.println("======= 같은 패키지 내 접근 =======");
		
		AccessTarget a1 = new AccessTarget(); //public 생성자
		AccessTarget a2 = new AccessTarget("hello"); //protected 생성자
		AccessTarget a3 = new AccessTarget(123); //default 생성자
//		AccessTarget a4 = new AccessTarget(3.14); //private 생성자
		
		  a1.publicMethod();
	      a1.protectedMethod();
	      a1.defaultMethod();
	//	      a1.privateMethod(); 
	      a2.publicMethod();
	      a2.protectedMethod();
	      a2.defaultMethod();
	      a3.publicMethod();
	      a3.protectedMethod();
	      a3.defaultMethod();
	}
}


==========================================================================

package accessmodifier02;

import accessmodifier01.AccessTarget;

public class AccessTest extends AccessTarget{

   public AccessTest() {
//	      super();
      super.protectedMethod(); //상속 통해 접근 가능
      this.protectedMethod(); //현재 클래스의 객체 통해 접근 가능
   }
   
   public void testAccess() {
//	      AccessTarget at = new AccessTarget("test"); //protected 생성자 접근 불가
      this.protectedMethod(); // 상속통해 접근 가능
   }
   
}


==========================================================================

package accessmodifier02;

import accessmodifier01.AccessTarget;

public class SomeName {
	public static void main(String[] args) {
		System.out.println("=======다른 패키지에서 접근=======");
		AccessTarget a1 = new AccessTarget(); //public 생성자
//		AccessTarget a2 = new AccessTarget("hello"); //protected 생성자
//		AccessTarget a3 = new AccessTarget(123); //default 생성자
//		AccessTarget a4 = new AccessTarget(3.14); //private 생성자
		
		a1.publicMethod();
//		a1.protectedMethod();
//		a1.defaultMethod(); // 다른 패키지 + 직접 접근 불가
		
		AccessTarget test = new AccessTarget(); //자식클래스
//		test.testAccess; //상속으로 접근 가능
	
	}
}


==========================================================================

package accessmodifier03;
//2번 : private 접근제한자
public class Person {
	//필드
	private String name;
	private int age;
	
	//필드에 private 접근자가 붙었다면 반드시 setter, getter가 따라와야함
	
	//setter 메소드 : name 필드 값을 설정(매개변수)
	//set 뒤에 필드명 붙여서 카멜표기법
	public void setName(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
//
//	public void setAge(int age) {
//		this.age = age;
//	}
//
//	public int getAge() {
//		return age;
//	}

	void printInfo() {
		 System.out.println(this.name + "님 환영합니다!");
	}
}


==========================================================================

package accessmodifier03;
//2번 : private 접근제한자
public class PersonMain {
	public static void main(String[] args) {
		Person p1 = new Person();
//		p1.name = 짱구;
		p1.setName("짱구");
		System.out.println(p1.getName());
		p1.printInfo();
	}
}


==========================================================================

package accessmodifier04;
// 3번 : final
public class Car {
	//final : 최종을 의미하는 키워드
	//final 변수(상수) : 최종적인 값 => 값 변경 불가
	//final 클래스 : 최종적인 클래스 => 더 이상 상속불가(자식클래스 만들 수 없다)
	//final 메소드 : 최종적인 메소드 => 오버라이딩 불가
	
	//필드
	private int speed;

	//getter, setter : alt + shift + s + r 
	public int getSpeed() {
		return speed;
	}

	public void setSpeed(int speed) {
		this.speed = speed;
	}
	
	//메소드
	void speedUp() {
		speed += 10;
		System.out.println("현재시속 : " + this.speed);
	}
	
	//final 메소드 : 오버라이딩 불가한 메소드
	final void stop() {
		System.out.println("브레이크를 밟아 차를 멈춥니다");
		this.speed = 0;
	}
	
	
}


==========================================================================

package accessmodifier04;
// 3번 : final
public class SuperCar extends Car{

	//오버라이딩 : alt + shift + s + v
	@Override
	void speedUp() {
				//getspeed()안에 매개변수 저장
		setSpeed(getSpeed()+ 20); //private 필드의 접근은 항상 getter와 setter를
//		통해 처리
		System.out.println("슈퍼카가 가속합니다 : " + getSpeed());
	}
	
}


==========================================================================

package accessmodifier04;
// 3번 : final
public class CarMain {
	public static void main(String[] args) {
		
		Car c = new Car();
//		c.speed = 100();
		c.setSpeed(100);
		System.out.println(c.getSpeed());
		c.speedUp();
		
		SuperCar superCar = new SuperCar();
		superCar.speedUp(); 
		//자식클래스의 객체는 오버라이딩 된 메소드를 호출
		superCar.stop(); 
		//자식클래스의 객체로 부모클래스의 final 메소드를 호출
	}
}


==========================================================================

package casting01;
//4번 : casting 자식 클래스
public class SmartTv extends Tv{

	//메소드
	void netflix() {
		System.out.println("넷플릭스 실행");
	}
}


==========================================================================

package casting01;
// 4번 : casting 자식 클래스
public class Tv {
	//필드
	boolean power;
	int ch;
	int vol;
	
	//메소드
	void powerOnOff() {
		System.out.println("tv 전원을 켜거나 끕니다");
	}
	
	void chUp() {
		System.out.println("채널을 올립니다");
	}
	
	void chDown() {
		System.out.println("채널을 내립니다");
	}
}


==========================================================================

package casting01;
//4번 : casting 자식 클래스
public class TvMain {
	public static void main(String[] args) {
		//각각 클래스 객체
		Tv tv = new Tv();
		System.out.println(tv);
//		tv.netflix(); //부모 객체의 값은 자식 클래스에 있는 멤버 사용 불가능
		tv.powerOnOff();
		
		SmartTv smartTv = new SmartTv();
		System.out.println(smartTv);
		smartTv.netflix(); //자식 객체의 값은 자식 클래스에 있는 멤버 사용 가능
		smartTv.chUp(); //자식 객체의 값은 부모 클래스에 있는 멤버도 사용 가능
		
//		Up casting
		//방법1
		//SmartTv()는 Tv 클래스의 참조 변수 tv1에 할당된다
		//부모클래스 타입의 참조 변수로 자식 클래스 타입의 참조값을 대입하는 것이다
		//부모클래스자료형 참조변수명 대입연산자 new 자식생성자();
		
		Tv tv1 = (Tv) new SmartTv(); //부모 타입의 객체에 자식의 참조값을 대입
		System.out.println(tv1);
//		tv1.netflix(); //업캐스팅 되면 자식 클래스에 만들어진 멤버는 사용 불가능하다
		
		//방법2
		Tv tv2 = (Tv) smartTv;
		//tv2는 SmartTv 클래스의 객체를 참조하면 업캐스팅으로 인해 Tv 타입으로 취급된다
		//따라서 Tv 클래스의 필드와 메소드에만 접근할 수 있다
		
		//방법3
		Tv tv3 = new SmartTv();
//		부모 클래스 타입의 참조 변수로 자식 클래스 타입의 객체를 참조한다
//		부모 클래스 타입의 참조변수에 자식 클래스 타입의 객체의 주소값(참조값)을 저장한다
//		tv3.netflix();
		
		//Down Casting
		SmartTv stv3 = (SmartTv) tv3;
		stv3.netflix();
		
		//잘못된 Down Casting
//		SmartTv stv = (SmartTv) new Tv();
//		System.out.println(stv);
//		빨간 밑줄이 나타나지 않고 실행해야 오류가 나는 것을 알 수 있다
//		Down Casting은 반드시 Up Casting 된 값으로 해야한다
//		즉, Up Casting 된 값을 다시 원래 자식 타입으로 되돌리는 것이 Down Casting이다
	}
	
}


==========================================================================

package casting02;
//5번 : 자식 객체의 타입이 여러개인지 확인 - 자식클래스
public class Child extends Parents{

}


==========================================================================

package casting02;
// 5번 : 자식 객체의 타입이 여러개인지 확인 - 부모클래스
public class Parents {

}

==========================================================================

package casting02;
//5번 : 자식 객체의 타입이 여러개인지 확인 - 메인클래스
public class TypeTest {
	public static void main(String[] args) {
		
		
		Parents p = new Parents();
		Child c = new Child();
		
		System.out.println(p);
		System.out.println(c);
		
		
		// 객체명 instanceof 클래스명 연산자 => boolean타입 결과
		// instanceof : 객체가 특정 클래스나 해당 클래스의 자식클래스인지 확인할 때 사용함
		System.out.println(p instanceof Parents);
		System.out.println(c instanceof Child);
		System.out.println(p instanceof Child); //false
		System.out.println(c instanceof Parents); //true
		//자식 클래스 타입의 객체는 부모 클래스 타입도 동시에 갖는다!!
		
		Parents pp = new Child();
		Child cc = (Child) pp; //자식클래스에서 부모클래스로 바꾸는건 반드시 강제형변환 필요
		
	}
}


==========================================================================

package casting03;
// 6번 : 캐스팅의 특징
public class Animal {
	//필드
	String name;
	int age;

	//생성자
	public Animal(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	//메소드
	void crying() {
		System.out.println("울어!");
	}
}



==========================================================================

package casting03;
// 6번 : 캐스팅의 특징
public class Cat extends Animal{
	
	//생성자
	public Cat(String name, int age) {
		super(name, age);
	}

	//메소드 오버라이딩
	@Override
	void crying() {
		System.out.println("야옹!!");
	}
}


==========================================================================

package casting03;
// 6번 : 캐스팅의 특징
public class Dog extends Animal{

	//생성자
	public Dog(String name, int age) {
		super(name, age);
	}

	//메소드 오버라이딩
	@Override
	void crying() {
		System.out.println("멍멍!!");
	}

	//메소드
	void walk() {
		System.out.println("산책가자!");
	}
}


==========================================================================

package casting03;
// 6번 : 캐스팅의 특징
public class CastingTest {
	public static void main(String[] args) {
		
		Animal animal = new Animal("동물", 2);
		System.out.println(animal);
		animal.crying();
		
		//Up Casting
		Animal animal2 = new Dog("바둑이", 3);
		System.out.println(animal2);
		// 1. 같은 메소드가 부모에도 있고 자식에도 있는 경우(오버라이딩)
		// 업캐스팅을 하여도 오버라이딩 된 메소드가 실행된다
		animal2.crying();
		
		
		
		// 2. 메소드가 부모에는 없고 자식에서만 추가된 경우
		// (부모에 존재하지 않는 멤버에 접근하려는 경우)
//		animal2.walk();
		//자식클래스에서 추가한 멤버는 부모 타입의 참조변수로는 접근할 수 없다
		//이 경우 다운 캐스팅을 해야한다
		((Dog)animal2).walk();
		
		
		//객체 생성
		Dog dog = new Dog("별이", 4);
		Cat cat = new Cat("달이", 3);
		CastingTest.printTest(dog);
		CastingTest.printTest(cat);
//		메소드 하나로 매개변수 여럿을 받음
		
		CastingTest.tryWalk(dog);
		CastingTest.tryWalk(cat);
	}
	
	// 1. 메소드의 매개변수로 여러 타입의 값을 받는 경우
	// 일반적으로는 각각의 타입을 처리하는 메소드를 별도로 만들어야한다 (메소드 오버로딩)
	// 매개변수에 업캐스팅을 하게 되면 1개의 타입으로 자식 클래스의 값들을 담아줄 수 있다
	// 메소드가 적을때는 하나하나 만들어도 되긴하나 여럿일경우 그러면 유지보수성이 떨어진다
	
	
	// 2. 같은 부모 클래스가 존재한다면 매개변수를 부모 타입으로 받는다(업캐스팅)
	// 하나의 메소드에서 매개변수를 부모타입으로 만들면 여러 자식 타입을 받아서 사용이 가능하다(다형성)
	static void printTest(Animal ani) {
		System.out.println(ani.name + "이/가 운다");
		ani.crying(); // 업캐스팅 된 객체가 들어와도 오버라이딩 된 메소드가 호출된다
	}
//	Animal ani = new Dog();
//	Animal ani = new Cat();
//	Animal ani = new Animal();
	
	// 3. 부모 클래스에 존재하지 않는(자식 클래스에서 만든) 멤버에 접근하기 위해서는
	// Down Casting을 해줘야한다
	// 업캐스팅을 해서 True라면 호출, 아니라면 다운캐스팅
	
	static void tryWalk(Animal ani) {
	// 매개변수로 받아온 객체의 주소값이 Cat 타입인지, Dog 타입인지 확인한다
		if(ani instanceof Dog) {
			//Dog 타입이 맞다면 Dog로 Down Casting 한다
			((Dog)ani).walk();
		}else {
			System.out.println("산책안가");
		}
	}

}

==========================================================================




==========================================================================

package casting04;
// 7번 : 캐스팅 예제
public class Hero {
	//필드
	private String name;

	//생성자
	public Hero(String name) {
		super();
		this.name = name;
	}

	//getter 메소드
	public String getName() {
		return name;
	}
	
	//메소드
	void superPower() {
		System.out.println(this.name + "이/가 슈퍼파워를 사용합니다");
	}
	
	void say() {
		System.out.println(this.name + "이/가 대사를 외칩니다");
	}

}

==========================================================================

package casting04;

public class Hulk extends Hero{

	//생성자
	public Hulk(String name) {
		super(name);
	}
	
	//메소드 오버라이딩
	void superPower() {
		System.out.println(this.getName() + "이가 거대해지며 공격합니다");
	}
}

==========================================================================

package casting04;

public class IronMan extends Hero{

	//생성자
	public IronMan(String name) {
		super(name);
	}

	@Override
	void superPower() {
		System.out.println(this.getName() + "이가 수트를 입고 날아다닙니다");
	}
}


==========================================================================

package casting04;
// 7번 : 캐스팅 예제
public class Main {
	public static void main(String[] args) {
		
		//업캐스팅
		Hero ironMan = new IronMan("아이언맨");
		ironMan.superPower(); // 업캐스팅 되어도 오버라이딩 된 메소드가 호출
		
		Hero hulk = new Hulk("헐크");
		hulk.superPower();
		
		//다운캐스팅
		IronMan ironMan2 = (IronMan) ironMan; 
		System.out.println(((Hulk)hulk));
		
	}
}


==========================================================================