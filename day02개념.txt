0. 복습
버전
	프로그램을 수정하여 개선한 것
	1.1	메이저버전번호.마이너버전번호
	1.1.1	메이저버전번호.마이너버전번호.패치버전번호


버전번호
	소프트웨어나 프로젝트의 업데이트 레벨을 식별하기 위해 사용
	(안써도 문제는 없으나 나중에 구분하기가 매우 힘들어짐!)

버전관리
	로컬(Git)(내 pc)/원격(GitHub)(전체 공유)

버전관리시스템
	git, svn

Git-Hub
	git을 저장하고 공유할 수 있는 서버를 제공하는 사이트.
	
Git 구조
	Working Directory(작업폴더)
		작업하는 공간
		git init => .git

		파일의 상태	untracked

	Staging Area(스테이징 영역)
		스테이징 영역에 있는 파일들은 git의 관리 대상
		git add . or git add 파일명
		
		파일의 상태	tracked
		tracked 상태의 종류 3가지
			unmodified	수정이 되지 않은 상태
			modified	수정이 된 상태
			staged		로컬 저장소에 올릴 준비가 완료된 상태

	Local Repository
		staged 상태의 파일을 commit 하면 로컬 저장소에 저장된다
		git commit -m "커밋메시지"	

	Remote Repository
		git-hub 원격 저장소
		원격 저장소에 올리기 위해 git-hub 저장공간(repository)을 만들고	
		그 주소를 git bash를 이용해 연결해주는 작업이 선행되어야한다
		push(로컬저장소 -> 원격저장소로 올릴때 씀) 
		pull(원격저장소 -> 로컬저장소로 내릴때 씀)

기본명령어
	git -v(버전 확인하기)
	git config --list(설정 확인하기)
	git config --global user.name "깃허브이름"
	git config --global user.email "이메일주소"

	-와 --는 갯수를 틀릴시 오류가 발생하니 주의

	git init
	git status
	git add . or  파일명
	git commit -m "커밋메시지"
	git log
	커밋날짜, 시간, 메시지, 체크섬, 작업자
	git log --pretty=oneline
	git checkout 체크섬(앞 7자리) or 브랜치이름 or -(가장 최근 시점으로 되돌아가기)
	git commit --amend -m "수정할 메시지" (커밋한 메시지를 수정할때)

1) 브랜치(branch)
	1. 일반적인 버전 업데이트
		커밋a - 커밋 a + b - 커밋 a + b + c

	2. c작업을 취소하고 d작업을 추가할 때
		1)커밋a - 커밋 a + b - 커밋 a + b + c
		2)커밋a - 커밋 a + d - 커밋 a + c + d
		
	3. 여러 버전을 나누어 작업하고 싶을 때
		1.커밋a - 커밋 a + b - 커밋 a + b + c
		2.커밋a - 커밋 a + b - 커밋 a + b + d
			            (1에서 작업한 abc를 날리지 않고 새로 함)

	한개의 저장소를 여러 갈래로 나누어 관리할 수 있게 해주는 개념
	브랜치끼리는 서로 영향을 받지 않기 때문에 개별적인 작업을 진행할 수 있다
	Git은 기본적으로 master 브랜치르 메인으로 사용한다
	(브랜치라는 것은 독립적으로 작업할 수 있는 하나의 선이다)
	GitHub는 기본적으로 main 브랜치를 메인으로 사용한다
	

- 브랜치 명령어
	git branch
		현재 브랜치의 목록을 보기
	git branch 브랜치이름
		새 브랜치 만들기
	git checkout 브랜치 이름
	git switch 브랜치 이름
		브랜치 이동 명령어
	git switch -c 브랜치이름
		브랜치를 만들고 해당 브랜치로 바로 이동
	git branch -D 브랜치이름
		브랜치 삭제
	git branch -m 기존이름 변경할 이름
		브랜치명 수정			
	git branch -r 
	remote repository에 있는 브랜치 확인
	
	git restore --staged 파일명
	git에 잘못 넣은 파일 삭제

	git와 github는 마스터명이 다름, 그래서 github에선 main으로 바꿔올려야함
	git branch -m master main
		      (기존)  (신규)

2. 원격 저장소(Remote Repository)

1) 저장소의 종류
	로컬 저장소		개인 pc에서 사용하는 저장소
	원격 저장소 	git-hub 같은 사이트 등을 이용하여 어떤 서버에 올려놓고 사용하는 저장소이다

깃허브 로그인 상태에서 원격 저장소를 만들어야함
깃허브 사이트 좌측 상단 혹은 중단의 'Create a new repository' 클릭 ( 기존에 만들어둔게 있으면 'new'로 나옴)
repository를 만들때는 기존 이름으로 만드는게 안되니 주의!

kdt_test01로 생성, 이름은 매번 다르게 만들것


Description (optional)
설명문. 작성해도 되고 안해도 됨

public - 모두에게 공유되는 전체공개
private - 자신만 볼 수 있는 나만보기

add a README file 체크하기

Add .gitignore 설정시 특정 설정을 무시가능, 수업에선 안씀
(팀원들마다 이클립스 등 다른 파일을 넣어도 깨지지 않음)

우측위 녹색 <>Code 클릭하면 링크가 나옴
해당 링크로 가져온 브랜치는 메인만 존재함,
다른 브랜치는 가져와지지 않음.
그러므로 다른 사람들과 공유하기 위해서는 모든 브랜치를 메인으로 모아야함.

git clone < 원격 저장소에 있는 내용을 그대로 복사해옴
클론을 받아올때는 초기화하지 않고 해당 링크를 그대로 붙여넣음

전체를 복사해온다 > clone
일부만 받아온다 > pull

2) 원격 저장소 관련 명령어
	git remote add 원격저장소이름 주소
		원격 저장소를 먼저 만들어야한다!!
		원격 저장소를 내 로컬과 명령하는 명령어
		보통 원격 개인 저장소 이름은 origin을 많이 사용한다

	git remote -v
		원격 저장소와 연결이 잘 되었는지 확인하는 명령어
		origin 주소 (fetch)
		origin 주소 (push)
		둘 다 떠야 정상이다
		- fetch : 일종의 새로고침 역할
		- push : 원격 저장소에 파일을 올릴 때 사용한다
		origin 명이 없으면 -v를 해도 출력이 안됨. 반드시 필요하다		

	git pull 원격저장소이름 브랜치이름
		원격 저장소에 저장한 파일들을 로컬 저장소로 가져오는 명령어
		내가 작업중인 파일을 그대로 pull하는 습관을 들일 것!
	
	git push 원격저장소이름 브랜치이름
		로컬 저장소에 커밋한 파일을 원격 저장소에 저장하는 명령어

	git clone 원격저장소주소 저장할경로
		원격 저장소에 있는 파일들을 복사하여 로컬 저장소로 가져오는 명령어
		다른 사람이 서버에 올려놓은 git 저장소를 내 컴퓨터에 똑같이 복사해오는 용도로 사용한다
		보통 처음 세팅을 할 때 사용한다
		주의사항!!! 클론할 때는 git init을 하지 않는다!!!
		git init은 내 로컬에서 .git폴더를 생성해서 처음부터 관리하는것 이고
		git clone은 다른 사람이 관리하던 log 내용까지 전부 복제해오는 것이다
		그냥 클론을 받으면 작성 권한이 없음, 권한을 받아야 가능함
		settings - collaborators (비밀번호 입력) - add people 클릭 - 
		팀원의 깃허브 아이디(내꺼는 bouncewater48)를 등록,추가 - 화면 우상단 혹은 이메일로 온 초대 		수락 후 accept invitation까지 해야 권한 받음

	fatal : refusing to merge unrelated histories 에러 발생
	두개의 깃 저장소에 서로 다른 히스토리를 가지고 있을 때 발생한다
	기본적으로 두 저장소가 공통의 부모 커밋이 없다고 판단되면 에러가 나타난다
	발생 할 수 있는 경우
	- 빈 저장소에서 git init 명령어를 사용해서 새로운 저장소를 만들었을 때
	- 로컬 저장소를 초기화하고 리모트 저장소를 추가한 후에 리모트 저장소에서 변경사항을 가져올 때

	해결 방안
	git pull origin main --allow-unrelated-histories
	두 저장소의 히스토리를 강제로 병합하는 명령어
	항상 현재 변경사항의 내용을 백업하고 검토한 후에 사용해야한다(병합이 문제를 일으킬 가능성이 있기 때문에)

깃허브에서 README 적힌걸 눌러서 Edit에 들어가면 마크다운 문법 사용 가능

HEAD -> main, origin/main
main은 로컬, origin/main은 원격 저장소












