day10_작업물 (java 8일차)

Review


public class MethodTask02

1. 정수1개를 받아서 짝수입니다, 홀수입니다를 반환하는 메소드

	// 1. 정수1개를 받아서 짝수입니다, 홀수입니다를 반환하는 메소드
	// 메소드명 : checkNum	
		
	//1) 기능
	//2) 리턴타입 => void
	//3) 메소드명 => checkNum
	//4) 매개변수 => 정수형 변수1개
	//5) 실행할문장 => 삼항연산자
	//6) return => return 매개변수 % 2 == 0 ? "짝수입니다" : "홀수입니다"
	//7) 리턴타입 변경 => String
	String checkNum(int number) {
		return number % 2 == 0 ? "짝수입니다" : "홀수입니다";
	}

		//매개변수 o, 리턴값 o => syso(객체명.메소드명(인수));
		System.out.println(mt.checkNum(10));
		System.out.println(mt.checkNum(-7));


2. 10칸짜리 정수 배열을 받아 총합을 계산하여 반환하는 메소드

	//2. 10칸짜리 정수 배열을 받아 총합을 계산하여 반환하는 메소드
	//메소드명 : getSum
	//1) 리턴타입 => void
	//2) 메소드명 => getSum
	//3) 매개변수 => int[] 매개변수명
	//4) 실행할문장(기능 구현) =>
	//		총합구할변수 선언
	//		for-each문(자료형 변수명 : 배열명){
	//			총합구할변수 += 변수명;
	//		}
	//5) return 총합구할변수
	//6) 리턴타입 => int
	
	int getSum(int[] numbers) {
		int total = 0;
		for(int num : numbers) {
			total += num;
		}
		return total;
	}
		//매개변수 o, 리턴값 o => syso(객체명.메소드명(인수));
			
		System.out.println(mt.getSum(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));
		int[] numbers = {10, 20, 10, 20, 10, 20, 10, 20, 10, 20};
		System.out.println(mt.getSum(numbers));


3. 문자열을 매개변수로 받아 거꾸로 뒤집어 반환하는 메소드

	//3. 문자열을 매개변수로 받아 거꾸로 뒤집어 반환하는 메소드
	//메소드명 : reverseStr
	// hello => olleh
	
	//3-1) char[]을 이용한 방식
	//리턴타입 => void
	//메소드명 => reverseStr1
	//매개변수 => String 1개
	//실행할 문장 => 
	//	조건식(if문) 매개변수 == null
	//			{ return; }
	//	int 변수1 = 매개변수명.length();
	//	문자형 배열 변수2 = new char[매개변수명.length()];
	//	반복문(for문) int i = 0; i < 길이; i++;
	//	{	변수1[i] = 매개변수.charAt(변수1 - 1 - i); } 
	//return => 문자열변수
	
	//매개변수 o, 리턴값 x 메소드 정의
//	char[] reverseStr1(String str) {
	String reverseStr1(String str) {
//		if(str == null) {
//			return null; //메소드 즉시 종료
//		}
		int len = str.length();
		char[] reverse = new char[len];//reverse라는 문자열 생성
		String result = "";	
		for(int i = 0; i < len; i++) {
			reverse[i] = str.charAt(len - 1 - i);
			//문자열을 반대로 (hello는 olleh로) 반환하겠다
//			System.out.println(reverse[i]);
//			result += reverse[i];
		}
//		return reverse ;
		return new String(reverse);
	}
	
	
	//3-2) 뒤어서부터 문자를 하나씩 더해서 새로운 문자열 만드는 방식
	//	리턴타입 =>  void
	//	메소드명 => reverseStr2
	//	매개변수 => String str
	//	실행할 문장 =>
	//	 조건문 if(str == null){ return null; }
	//	 문자열 변수 선언
	//	 반복문(for문) int i = str.length() -1; i >= 0; i--
	//		{ 변수 += str.charAt(i); }
	//	return => 변수
	// 리턴타입 변경 => String
	
	String reverseStr2(String str) {
		if(str == null) {
			return null;
		}
		String result ="";
		for(int i = str.length() -1; i >= 0; i--) {
			result += str.charAt(i);
		}
		return result;
	}
	
	
	//3-3) char[] 새로 만들어서 앞뒤 바꿔서 복사하는 방식
	// 리턴타입 => void
	// 메소드명 => reverseStr3
	// 매개변수 => String str
	// 실행할 문장 (기능구현)
	//		조건문if str ==null {return null;}
	//		정수형 변수1 = str.length();
	//		문자형배열 변수2 = new char[변수1];
	//		반복문for문 int i = 0; i < 변수1; i++
	//		{	변수2 = str.charAt(변수1 - 1 - i); }
	//		String 변수3 = ""
	//		for-each문 사용
	//		for(char 변수 : 변수2){
	//			변수3 += 변수;
	//		}
	// 리턴타입 변수3; String타입으로 변경

//3-4) 메모리를 효율적으로 사용하는 메소드를 이용하는 방식
	//아직 안 배운 내용이므로 이건 수업중에 안쓸것이나, 코딩테스트나 PCCE 시험을 볼거면 알아두면 좋음!
	//String까지 다 배우고나서 사용예정
	//아래 2줄만 작성하면 끝남
	
	
	String reverseStr3(String str) {
		if(str == null) {
			return null;
		}
		
		int len = str.length();
		char[] reverse  = new char[len];
		
		for(int i = 0; i < len; i++) {
			reverse[i] = str.charAt(len - 1 - i);
		}
		String result= "";
		for(char c : reverse) {
			result += c;
		}
		return result;
	}


		System.out.println("=======3-1번=======");
		//매개변수 o, 리턴값 x 메소드 정의
//		mt.reverseStr1(null); //null은 출력되면 안됨
		System.out.println(mt.reverseStr1("철수")); 
		//한글이나 영어나 다 거꾸로 반전되서 출력

	3-4)  String reverseStr4(String str) { //String타입 반환
		return new StringBuilder(str).reverse(str).reverse().toString();
	}


4. 정수형 배열과 찾을 값을 매개변수로 받아서 배열에 존재하면 true를 반환하는 메소드 만들기

	//4. 정수형 배열과 찾을 값을 매개변수로 받아서 배열에 존재하면 true를 반환하는 메소드 만들기
	//메소드명 : contains
	//배열 요소 중에 10이라는 값을 반드시 넣고 10을 매개변수로 전달
//		syso(메소드명(배열명, 10)) => true
//		return타입 : boolean 타입
	
	// 리턴타입 => void -> boolean타입
	// 메소드명 => contains
	// 매개변수 => 정수형배열 1개, 정수형변수 1개
	// 구현부 {
	//		if(매개변수1(정수형배열) == null) {
	//		  return false; }  null이 들어가면 출력되면 안되므로
	//		for(정수형 변수 : 배열명){
	//		  조건문(if문) 변수 == 정수형변수 { 배열에 찾을값이 있을떄 true
	//				return true;
	//			}
	//
	//		}
	//		return false; 배열에 찾을값이 없을때 false
	// }
	
	boolean contains(int[] arr, int num) {
		if(arr == null) {
			return false;
		} // if문을 삭제시키면 for문으로 바로 가지만, arr이 정의되지 않았기에 오류가 발생
		for(int i : arr) {
			if(i == num) {
				return true;
			}
		}
		return false;
	}

		System.out.println("=======4번=======");
//		int[] ar = null; //false
		System.out.println(mt.contains(null, 0)); //위에 적은거랑 같은 뜻임
		int[] ar = {1, 2, 3, 10};
		System.out.println(mt.contains(ar, 10)); // ar안에 있는걸 적으면 true
	
	7. 아이디와 비밀번호를 매개변수로 받아 검증, 시도횟수 3회 넘기면 잠금 반환

//7. 아이디와 비밀번호를 매개변수로 받아 검증, 시도횟수 3회 넘기면 잠금 반환
	//메소드명 : loginTry	
	// 메소드에는 모든 기능이 들어가면 안되고 무조건 기능 1가지만!
	// 메소드 안에서 sc.close 메소드를 사용하면 main메소드에서 더 입력받을게 있어도 
	// 강제로 끝나기(종료)에, 나중에 입력받으려 할때 오류터짐
	
	//입력이 따로 없고 매개변수로만 전달될때를 가정한것
	// 리턴타입 => void => String
	// 메소드명 => loginTry
	// 매개변수 => 문자열 2개
	// 구현부 =>
	//		고정값 id, pw 선언(상수)
	//		횟수 확인할 변수1 선언
	//		if문 변수1 >= 3 // 2번 틀렸을때도 확인해야해서 if if문 사용
	//			return 계정잠금 / 시작하자마자 계정잠금 확인
	//		if문 상수id.equals(매개변수id) && 상수pw.equals(매개변수pw)
	//			변수1 초기화 / 로그인 성공이니 횟수 초기화
	//			return 로그인 성공
	//		else {
	//			변수1++
	//			if(변수1 >= 3){
	//			return 계정잠금} /3 이상일때 계정잠금 확인
	//		return 로그인실패
	//		}
	//}}
	
	//메소드 밖에서 클래스 안에 변수 선언
//	int tryCount = 0; 
	// tryCount를 0부터 시작해서 1번이 아닌 0번부터 출력, 2번째가 3번이므로 계정잠금
	
//	String loginTry(String inputId, String inputPw) {
//							admin			1234
//		final String ID = "admin";
//		final String PW = "1234";
//		System.out.println(tryCount + "번");
//		int tryCount = 0; // 시도할 횟수
//		if(tryCount >= 3) {
//			return "계정잠금";
//		}
//		if(ID.equals(inputId) && PW.equals(inputPw)) {
//			tryCount =0;
//			return "로그인 성공";
//		}else {
//			tryCount++;
//			if(tryCount >=3) {
//				return "계정잠금";
//			}
//			return "로그인 실패";
//		}
//	}
	
	//loginTry(검증만)
//	String loginTry1(String inputId, String inputPw) {
//		final String ID = "admin";
//		final String PW = "1234";
//		Scanner sc = new Scanner(System.in);
//		
//		if(ID.equals(inputId) && PW.equals(inputPw)) {
//			return "로그인 성공";
//		}
//		return PW;
//		
//	}

		System.out.println("=======7번=======");
//		System.out.println(mt.loginTry("admin", "1234")); //1회실패
//		System.out.println(mt.loginTry("admin", "12345")); //2회실패
//		System.out.println(mt.loginTry("admin", "12345")); //3회실패 => 잠금
//		System.out.println(mt.loginTry("admin", "12345")); //3회실패 => 잠금
	
		int tryCount = 0;
		String id, passwd, result;
		Scanner sc = new Scanner(System.in);
		
		while(true) {
			System.out.println("아이디 입력 : ");
			id = sc.nextLine();
			System.out.println("비밀번호 입력 : ");
			passwd = sc.nextLine();
			
			result = mt.loginTry1(id, passwd);
			
			if(result.equals("로그인 성공")) {
				System.out.println("로그인 성공");
				break;
			}else {
				tryCount++;
				if(tryCount >= 3) {
					System.out.println("3회 이상 실패로 계정 잠금");
					break;
				}
				System.out.println("로그인 실패");
			}
		}
	}


============================================================================================

Method


1번 : 메소드 사용 이유1 (중복된 코드의 제거)

package Method;
//1번 : 메소드 사용 이유1 (중복된 코드의 제거)
public class MethodBasic01 {
	public static void main(String[] args) {
		//동일한 작업을 수행하는 코드를 여러번 작성하는 대신 메소드로 정의하면
		//코드의 가독성과 효율성이 향상된다
		
		//동일한 로직을 여러번 작성
		System.out.println("총 합 : " + (5 + 10));
		System.out.println("총 합 : " + (1 + 2));
		System.out.println("총 합 : " + (10 + 29));
	
		MethodBasic01 m = new MethodBasic01();
		m.printSum(10, 29);
		m.printSum(5, 10);
	}
	//메소드를 사용한 경우
	void printSum(int num1, int num2) {
		System.out.println("num1의 값 : " + num1  + ", num2의 값 : "  + num2);
		System.out.println("총 합 : "  + (num1 + num2));
	}
		
/*
		총 합 : 15
		총 합 : 3
		총 합 : 39
		num1의 값 : 10, num2의 값 : 29
		총 합 : 39
		num1의 값 : 5, num2의 값 : 10
		총 합 : 15
*/
}

============================================================================================

2번 : 메소드 사용이유2(높은 재사용성)

package Method;
//2번 : 메소드 사용이유2(높은 재사용성)
public class MethodBasic02 {
	public static void main(String[] args) {
		
		//동일한 로직을 구현하기 위해 새롭게 코드를 작성할 필요없이
		//이미 작성된 메소드를 호출하면 된다
		//작성된 코드의 재사용성을 높힐 수 있다
		
		MethodBasic02 m = new MethodBasic02();
		
		System.out.println("첫번째 직사각형의 면적" + m.calculateArtea(5, 10));
		System.out.println("두번째 직사각형의 면적" + m.calculateArtea(500, 123));
		//계산메소드 하나를 만들어서 재사용함
//		첫번째 직사각형의 면적50
//		두번째 직사각형의 면적61500
	}
	//직사각형의 넓이 구하는 메소드
	int calculateArtea(int width, int height) {
		return width * height;
	}
}

============================================================================================

3번 : 메소드 사용이유3(유지보수에 유리함)

package Method;
//3번 : 메소드 사용이유3(유지보수에 유리함)
public class MethodBasic03 {
	public static void main(String[] args) {
		//(메소드는 1개의 부품, 해당 메소드만 수정하거나 지워도 나머지는 그대로 사용가능)
		// 코드의 구조를 모듈화(=부품화)함으로써 수정과 확장이 쉬워진다
		// 하나의 메소드만 변경하면 해당 메소드를 호출하는 모든 코드에 자동으로 반영되므로
		// 수정범위를 최소화 시킬 수 있다
		
		MethodBasic03 m = new MethodBasic03();
		System.out.println("메소드 이용 25의 세제곱 : " + m.calSquare(25));
		System.out.println("메소드 이용 3의 세제곱 : " + m.calSquare(3));
		
//		메소드 이용 25의 세제곱 : 15625
//		메소드 이용 3의 세제곱 : 27
		
	}
	
	//거듭제곱을 구하는 메소드
	int calSquare(int num) {
		return num * num * num; 
	}
}
============================================================================================

4번 : stack 메모리

package Method;
//4번 : stack 메모리
public class StackMethod {
	public static void main(String[] args) {
		
		//1. main 메소드 실행 -> 스택에 main 스택프레임이 생성
		//
		
		StackMethod s = new StackMethod();
		int result = s.add(10, 20);
		// add라는 스택프레임 안에 num1 = 10, num2 = 20이라는 값을 저장
		// add로 10 + 20 = 30을 출력하는 순간 되돌아가고 해당 스택프레임은 사라짐
		System.out.println(result);
//		System.out.println(num1); // 사용불가능한 상태, 오류 발생
		
/*
	    num1의 값 : 10num2의 값 20
		30
*/	
	}
	
	
	//두 정수의 합을 더하는 메소드
	int add(int num1, int num2) {
		System.out.println("num1의 값 : " + num1 + "num2의 값 " + num2);
		return num1 + num2;
	}
}
============================================================================================

5번 : 스택오버플로우 발생

package Method;
// 5번 : 스택오버플로우 발생
public class StackOverFlow {
	public static void main(String[] args) {
		
		recursiveMethod();
	}
	
	
	static void recursiveMethod() {
		recursiveMethod();
		//메소드 작성시 절대 위처럼 작성하지 않고, 반드시 종료조건을 포함함!!
		// 자기 자신의 메소드에서 다시 자기자신을 호출하는걸 재귀호출 이라고 부름
		// java.lang.StackOverflowError
		// 재귀 호출이나 반복적인 메소드 호출로 인해
		// 스택 프레임이 계속 쌓여서 스택영역의 크기 제한을 초과하면 발생
		// JVM이 할당한 스택영역의 최대 크기를 초과하므로 더 이상 메소드 호출 정보를 쌓을 공간이 없어서
		// StackOverFlowError 가 발생한다
		
		//한 Thread에서 사용가능한 Stack 크기는 1mb ~ 2mb 정도임
	}
}

============================================================================================

6번 : 메소드 오버로딩1

package Method;
// 6번 : 메소드 오버로딩1
public class MethodOverloading01 {
	public static void main(String[] args) {
		
		MethodOverloading01 m = new MethodOverloading01();
		m.addInd(10, 20);
		m.addDouble(30.5, 1.1);
		
	}
	
	//메소드 오버로딩 전
	void addInd(int num1, int num2) {
		System.out.println(num1 + num2);
	}
	
	void addDouble(double num1, double num2) {
		System.out.println(num1 + num2);
	}
}

============================================================================================

7번 : 메소드 오버로딩2

package Method;
// 7번 : 메소드 오버로딩2
public class MethodOverloading02 {
	public static void main(String[] args) {
		
		MethodOverloading02 m = new MethodOverloading02();
		System.out.println(m.add(10, 20));
		System.out.println(m.add(1, 2, 3));
		m.add(10.5, 3);
		m.add(3.3, 4);

//		30
//		6
//		13.5
//		7.3
	
	}
	
	int add(int num1, int num2) {
		return num1 + num2;
	}
	
	//매개변수의 개수가 다른 add메소드
	int add(int num1, int num2, int num3) {
		return num1 + num2 + num3;
	}
	
	//매개변수의 타입이 다른 add메소드
	void add(double num1, int num2) {
		System.out.println(num1 + num2);
	}
	
	//매개변수의 순서가 다른 add메소드
	void add(int num1, double num2) {
		System.out.println(num1 + num2);
	}
}

============================================================================================

8번 : Call By Value

package Method;
// 8번 : Call By Value
public class Callbyvalue {
	public static void main(String[] args) {
		
		int num = 10;
		System.out.println("main 메소드에서의 num의 값 : " + num);
		modifyNum(num);
		System.out.println("main메소드에서의 num의 값 : " + num);
	}
	
	static void modifyNum(int num) {
		System.out.println("modifyNuim 메소드에서의 num의 값 : " + num);
		num = 20;
		System.out.println("modifyNuim 메소드에서의 num의 값 : " + num);
	
//		main 메소드에서의 num의 값 : 10
//		modifyNuim 메소드에서의 num의 값 : 10
//		modifyNuim 메소드에서의 num의 값 : 20
//		main메소드에서의 num의 값 : 10
	}
	//값 자체가 복사되므로 메소드 내부에서 변경한 값이 원본에 영향을 끼치지않는다
}

============================================================================================

9번 : Call By Reference

package Method;
// 9번 : Call By Reference
public class Callbyreference {
	public static void main(String[] args) {
		
		//java의 기본 참조 타입 복사는 얕은 복사이다
		
		//참조값과 call by value
		int[] ar = {1, 2, 3};
		System.out.println("메소드 호출 전 : " + ar[0]); //1
		System.out.println(ar); //[I@3af49f1c
//		modifyArray(ar); 
//		System.out.println("메소드 호출 후 : " + ar[0]); //10

//		메소드 호출 전 : 1
//		[I@3af49f1c
//		[I@3af49f1c
//		메소드 호출 후 : 10
		
//		int[] ar = {1, 2, 3};
		System.out.println("array2 메소드 호출 전 : " + ar[0]);
		System.out.println(ar); //[I@3af49f1c
		modifyArray2(ar); 
		System.out.println("array2 메소드 호출 후 : " + ar[0]);
		System.out.println(ar);
		
	}
	
	static void modifyArray(int[] ar) {
		System.out.println(ar); //[I@3af49f1c
		ar[0] = 10; // 참조된 배열의 첫번째 값을 변경
	}
	
	//즉 배열의 참조값이 복사되어 전달되므로 메소드 내부에서 배열의 값을 변경하면
	//원본 배열에도 영향을 미친다
	
	static void modifyArray2(int[] ar) {
		ar = new int[] {10, 20, 30};
		System.out.println(ar);

//		메소드 호출 전 : 1
//		[I@3af49f1c
//		array2 메소드 호출 전 : 1
//		[I@3af49f1c
//		[I@19469ea2 //new int[] 로 생성된 신규 배열
//		array2 메소드 호출 후 : 1
//		[I@3af49f1c
	}
	//참조값이 복사되어 전달되므로 메소드 내부에서 새로운 객체를 참조하도록 변경하면
	//원본 배열에는 영향을 끼치지 않는다
}

============================================================================================

10-1번 : 클래스 - 사용자 정의 타입이다(자료형)

package classBasic;
// 10-1번 : 클래스 - 사용자 정의 타입이다(자료형)
public class Student {
	//필드(속성, 특징)
	//이름, 수학점수, 영어점수, 국어점수, 평균점수
	String name;
	int math;
	int eng;
	int kor;
	double avg;
	//메소드(행동, 행위, 기능)
	//10-3번 : 연관성이 있는 저장공간과 기능을 한 곳에 모아 관리할 수 있다
	
	//점수의 총합을 반환하는 메소드
//	void => int
	int getTotal() {
		//같은 클래스에 있는 객체들을 재사용하고 묶을 수 있음
		return math + eng + kor; 
	}
}

============================================================================================

10-2번 : Student 클래스의 객체를 만들 클래스

package classBasic;
// 10-2번 : Student 클래스의 객체를 만들 클래스
public class StudentMain {
	public static void main(String[] args) {
		//객체를 만들때는 반드시 {}시작점이 필요
		Student st1 = new Student(); // new = 새로운 큰 메모리
		//st1이라는 새로운 저장공간을 선언, st2라는걸 새로 선언하면 별도로 생성이다
		System.out.println(st1); //주소값; st1이 여기에 저장됨
		Student st2 = new Student();
		System.out.println(st2); //주소값; st1과 주소값이 다르고 st2는 여기에 저장됨
		
		//Student 클래스에 만든걸 사용함
		
		//객체명.필드명 = 값;
		st1.name = "강승훈";
//		System.out.println(st1.name); //강승훈
//		System.out.println(st1.math); //0, 값을 안넣었음,기본값
//		System.out.println(st2.name); //null, st1이라는 필드에는 객체를 넣었으나 st2엔 안들어있다
//		System.out.println(st2.avg); //0.0, 값을 안넣었음, 기본값
//		st1.을 누르면 현재 사용가능한 필드명이 전부 자동완성으로 나온다
//		객체명, 저장가능타입, 클래스명 순으로 나옴
//		메소드는 메소드명, 리턴타입,
		st1.kor = 100;
		st1.eng = 100;
		st1.math = 100;
		
		//매개변수 x, 리턴값 o => syso(객체명.메소드명());
		System.out.println(st1.getTotal()); //300
		st1.avg = st1.getTotal() / 3.0;
		System.out.println("평균점수 : " + st1.avg); //평균점수 : 100.0
		
		// st2 객체의 국어점수 100점, 영어점수 50점, 수학점수 77점
		// 메소드 호출하여 000님의 평균점수는 소수점한자리까지 출력하기
		
		st2.name = "아무개";
		st2.kor = 100;
		st2.eng = 50;
		st2.math = 77;
		st2.avg = st2.getTotal() / 3.0;
		System.out.println(st2.getTotal()); //227
 		System.out.printf("%s님의 평균점수는 %.1f입니다", st2.name, st2.avg);
 		//아무개님의 평균점수는 75.7입니다
	}
}

============================================================================================

11-1번 : 클래스 특징1(사용자 정의 타입이다)

package classBasic2;
// 11-1번 : 클래스 특징1(사용자 정의 타입이다)
public class Student {
	
	//필드메소드 무조건 주석으로 작성
	String name;	//학생이름
	int age;		//학생나이
	double gpa;		//학점
}

============================================================================================

11-2번 : Student 클래스 main

package classBasic2;
// 11-2번 : Student 클래스 main
public class StudentMain {
	public static void main(String[] args) {
		
		
		Student st1 = new Student();
		//우측 참조변수를 왼쪽 참조값에 대입하여 주소 출력
		System.out.println(st1); //classBasic2.Student@279f2327;
		
		st1.name = "홍길동";
		st1.age = 17;
		st1.gpa = 4.5;
		
		System.out.println("이름 : " + st1.name);
		System.out.println("나이 : " + st1.age);
		System.out.println("학점 : " + st1.gpa);
	}
}

============================================================================================

12-1번 : 클래스의 특징2(연관성 있는 데이터와 기능을 한 곳에 통합)

package classBasic2;
// 12-1번 : 클래스의 특징2(연관성 있는 데이터와 기능을 한 곳에 통합)
public class Rectangle {
	//직사각형 정보와 관련된 기능
	
	//높이와 넓이 저장하는 필드
	int width;  //너비
	int height; //높이
	
	//메소드
	//넓이를 계산하는 메소드(매개변수 x, 리턴값 o 메소드) 정의
	int getArea() { //기본카멜 표기법
		return width * height;
	}
	
	//둘레를 계산하는 메소드(매개변수 x, 리턴값 x 메소드) 정의
	void getPerimeter() {
		System.out.println((width + height) *2);
	}
}

============================================================================================

 12-2번 : Rectangle 클래스 메인

package classBasic2;
// 12-2번 : Rectangle 클래스 메인
public class RectangleMain {
	public static void main(String[] args) {

	//객체화
	//클래스자료형 객체명 = new 생성자();
	Rectangle r1 = new Rectangle();
	System.out.println(r1);
		
	//객체명.필드명 = 값;
	r1.height = 20;
	r1.width = 10;
	
	//넓이 구하는 메소드 호출(매개변수 x, 리턴값 o => syso(객체명.메소드명());
	System.out.println(r1.getArea()); //200
		
	//둘레 구하는 메소드 호출(매개변수 x, 리턴값 x =>객체명.메소드명();
	r1.getPerimeter();//60
	}
}

============================================================================================

13-1번 : 클래스의 특징3(객체 생성의 틀)

package classBasic2;
// 13-1번 : 클래스의 특징3(객체 생성의 틀)
public class Car {
	//바퀴, 핸들, 색상, 엔진, 모델명, 제조사, 속도	
	
	
	//필드
	String model; //모델명(제조사)
	String color; //색상
	int speed;	  //속도
	
	//메소드	
	//속도를 증가시키는 메소드(매개변수 o, 리턴값 x 메소드 정의 => 객체명.메소드명(인수);
//	System.out.println("현재 속도 : " + myCar.speed);
	void accelerate(int value) {
		speed += value; 
		System.out.println("현재 속도 : " + speed);
	}
	
	//주행을 멈추는 메소드(매개변수 x, 리턴값 x 메소드 정의 => 객체명.메소드명();)
	void stop() {
		speed = 0; 
	}
	
	//속도를 감소시키는 메소드
	//매개변수 x 리턴값 x => 객체명.메소드명();
	//속도는 10씩만 감소되도록 기능 구현
	
	void decrease() {//바로 speed -= 10;을 넣으면 -10으로 출력, 조건문 추가필수
		//조건문 if < 0, 먼저 감소를 시키고 속도가 0보다 작은지 조건문으로 확인
		// if(speed >= 0)으로 하면 -10으로 내려가니 주의
			speed -= 10;
			if(speed < 0) {
			speed = 0;
		}	System.out.println("주행을 멈췄습니다");	
	}
}

============================================================================================

13-2번 : Car 클래스 main

package classBasic2;
// 13-2번 : Car 클래스 main
public class CarMain {
	public static void main(String[] args) {
		
		//객체화(인스턴스화)
		Car myCar = new Car();
		
		myCar.model = "Tesla Model 3";
		myCar.color = "black";
		myCar.speed = 0;
		
		System.out.println("모델명 : " + myCar.model);
		System.out.println("색상 : + " +  myCar.color);
		System.out.println("현재 속도 : " + myCar.speed);
	
		myCar.accelerate(120);
		
		myCar.accelerate(180);
		System.out.println(myCar.speed);
		
		myCar.stop();
		System.out.println("현재 속도 : " + myCar.speed);
		
//		모델명 : Tesla Model 3
//		색상 : + black
//		현재 속도 : 0
//		현재 속도 : 120
//		현재 속도 : 300
//		300
//		현재 속도 : 0
		
		myCar.accelerate(50);
		myCar.decrease();
		System.out.println("현재 속도 : " + myCar.speed);
		
		myCar.decrease();
		System.out.println("현재 속도 : " + myCar.speed);

		myCar.decrease();
		System.out.println("현재 속도 : " + myCar.speed);
		
		myCar.decrease();
		System.out.println("현재 속도 : " + myCar.speed);
	}
}

============================================================================================

메소드 문제(과제1)

package Task;
// 메소드 문제(과제1)
public class Task01 {
	//과제 제출할때 Task 패키지 압축해서 제출
	//1. 문자열 속의 단어를 공백 기준으로 세기
	//메소드명 : countWord
	//매개변수 : String str
	//ex) I love java => 3개 출력
	//ex) 안녕하세요 저는 강승훈입니다 java 공부 중입니다 => 6개 출력
	
	//2. 주민등록번호로 성별 판단하기
	//메소드명 : getGender
	//1, 3 => 남자
	//2, 4 => 여자
	
	//3. 학생 3명의 수학점수, 국어점수, 영어점수를 받아서 평균을 구하여
	//각 학생별 학점 구하기 (소수점 없이 정수형으로만, 등급은 평균점수로 계산)
	//메소드명 : getGrade
	// 95점 이상 A+
	// 90점 이상 A
	// 85점 이상 B+
	// 80점 이상 B
	// 75점 이상 C+
	// 70점 이상 C
	// 69점 이하 F
}

============================================================================================

메소드 문제(과제2)

package Task;
//메소드 문제(과제2)
public class Task02 {
	public static void main(String[] args) {
		
		//Animal 클래스 => 3개 객체만들기
		//필드 : 동물이름, 나이, 종
		//메소드 : 
		//동물이 먹이를 먹는 메소드		매개변수 1개
		//출력형태 => 동물이름이 00을 먹습니다
		
		//동물이 잠을 잡니다 출력하는 메소드
		// => 동물이름이 잠을 잡니다
		
		//동물의 생일 축하하는 출력 메소드
		// => 동물이름이 나이 생일을 축하합니다
	}
}

