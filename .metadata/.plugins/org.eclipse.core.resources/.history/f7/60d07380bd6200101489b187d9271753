-- 2번 : 서브쿼리

-- 1) 연관 서브쿼리
-- 최대 급여를 받는 직원 조회
-- SELECT EMPLOYEE_ID, FIRST_NAME, MAX(SALARY)
-- FROM EMPLOYEES; -- 조회하려는 행의 개수가 달라서 오류 발생
SELECT EMPLOYEE_ID, MAX(SALARY)
FROM EMPLOYEES;

SELECT MAX(SALARY)
FROM EMPLOYEES;

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEES);

-- 2) 비연관 서브쿼리
-- 각 직원의 급여가 부서별 평균 급여보다 높은 직원 조회

-- (1) 부서별 평균 급여 조회(12행)
SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- (2) 각 직원의 급여 조회(107행)
SELECT EMPLOYEE_ID, SALARY, DEPARTMENT_ID
FROM EMPLOYEES;

-- 메인쿼리
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY, E.DEPARTMENT_ID
FROM EMPLOYEES e
-- 메인쿼리 안 서브쿼리, EMPLOYEES e의 e를 이용한것
WHERE SALARY > (SELECT AVG(SALARY)
	FROM EMPLOYEES
	WHERE E.DEPARTMENT_ID = DEPARTMENT_ID
	GROUP BY DEPARTMENT_ID
)
ORDER BY E.DEPARTMENT_ID;

SELECT AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- 3) 단일 행 서브쿼리(서브쿼리의 결과가 1개)
-- 가장 오래된 입사일을 가진 직원의 사원번호, 이름, 입사일 조회

SELECT * FROM EMPLOYEES 
ORDER BY HIRE_DATE ASC;

-- 서로 다른 행을 확인시도, 오류 발생
SELECT FIRST_NAME, MIN(HIRE_DATE)
FROM EMPLOYEES;

-- (1) 가장 오래된 입사일을 조회
SELECT MIN(HIRE_DATE)
FROM EMPLOYEES;

-- (2) 서브쿼리
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE = (SELECT MIN(HIRE_DATE) FROM EMPLOYEES);

-- 다중 행 서브쿼리(서브쿼리의 결과가 여러 행을 반환)
-- 특정 부서에 속한 직원번호, 이름, 부서번호 조회
-- 부서명을 같이 조회

-- 다른 테이블 내용도 같이 조회하려하면 오류 발생, 행이 다르기 때문
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID -- , DEPARTMENT_NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = 60);
-- 해석할때는 () 안의 서브쿼리문 먼저 해석!
-- (1)DEPARTMENTS 테이블에서 60인 ID를 SELECT
-- (2)EMPLOYEES 테이블에서 DEPARTMENT_ID가 60인 직원의 EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID 조회

SELECT DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60;

-- 부서 이름까지 같이 조회하고 싶다? => 서브쿼리를 2번 쓰거나 JOIN을 이용해야한다
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES;

SELECT DEPARTMENT_ID, DEPARTMENT_NAME
FROM DEPARTMENTS;

-- 27행과 107행은 조건 없이 출력불가, WHERE절 추가
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID,
	(SELECT D.DEPARTMENT_NAME
	FROM DEPARTMENTS d
	WHERE DEPARTMENT_ID = D.DEPARTMENT_ID)
FROM EMPLOYEES;	
--SQL Error [1427] [21000]: ORA-01427: single-row subquery returns more than one row   
-- 이 에러는 단일 행 서브쿼리가 여러 행을 반환했기 때문에 발생한다
-- SELECT절 안에서 스칼라 서브쿼리를 사용하는 경우 해당 서브쿼리는 반드시 하나의 값(1행 1열)만 반환해야한다

-- 다중 행 서브쿼리를 쓸거면 테이블명마다 별칭을 붙히고, 양 테이블에 중복되는 컬럼을 사용하면 된다
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID,
	(SELECT D.DEPARTMENT_NAME
	FROM DEPARTMENTS d
	WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID)
FROM EMPLOYEES E;	

-- 완성본
-- WHERE절 안에서 다중 행 서브쿼리는 유지, SELECT절에서 스칼라 서브쿼리 사용
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID,
	(SELECT D.DEPARTMENT_NAME
	FROM DEPARTMENTS d
	WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID) 부서명
FROM EMPLOYEES E
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = 60);

-------------------------------------------------------------------------------------------------------
-- 전체 평균 급여와 부서별 평균 급여 구하기
SELECT AVG(SALARY)
FROM EMPLOYEES;

SELECT AVG(SALARY), DEPARTMENT_ID
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- 메인쿼리의 결과 행수보다 서브쿼리의 행의 수가 많으면 오류 발생!!
--SELECT AVG(SALARY), (SELECT * FROM EMPLOYEES)
--FROM EMPLOYEES;

-- 서브쿼리 사용 시에는 * 전체를 조회하는 경우 앞에 테이블별칭을 붙여서 테이블별칭명.* 형태로 조회해야한다
SELECT E.*, (SELECT AVG(SALARY) FROM EMPLOYEES)
FROM EMPLOYEES E;

SELECT DEPARTMENT_ID 부서번호, AVG(SALARY) 부서별평균급여, (SELECT AVG(SALARY) FROM EMPLOYEES) 전체평균급여
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- SELECT 절 : 계산된 값 또는 추가된 정보를 열로 표시
-- 각 직원의 사원 번호, 급여와 해당부서의 평균 급여 조회

-- 메인쿼리(107행) : 전체 직원의 번호, 이름, 급여 조회
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES;

-- 서브쿼리(12행) : 해당부서의 평균 급여 조회
SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT AVG(SALARY), DEPARTMENT_ID,
   (SELECT AVG(SALARY) 
   FROM EMPLOYEES)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- 각 직원의 사원번호, 이름, 급여, 해당 부서의 평균 급여 조회
SELECT EMPLOYEE_ID, SALARY, DEPARTMENT_ID,
	(SELECT AVG(SALARY)
	FROM EMPLOYEES E2
	WHERE E2.DEPARTMENT_ID = E1.DEPARTMENT_ID) 부서별평균급여
FROM EMPLOYEES E1;

GROUP BY DEPARTMENT_ID;


















































































































