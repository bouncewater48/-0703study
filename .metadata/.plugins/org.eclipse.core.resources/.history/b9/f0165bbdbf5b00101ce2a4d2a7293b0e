-- 3번 : 연산자2
-- (3) 관계연산자 (비교연산자)
/*
SELECT [DISTINCT] 컬럼명 [AS "별칭"]
FROM 테이블명
WHERE 조건식
ORDER BY 정렬할컬럼명 [ASC or DESC]
*/

-- 행을 고르기 위해서 WHERE 절을 사용한다
-- 직원의 이름, 성, 급여를 조회한다
SELECT first_name 이름, last_name 성, salary 급여	-- 3) 각 컬럼에 별칭을 붙여서 조회한다
FROM employees									-- 1) employees 테이블에서
WHERE salary >= 10000							-- 2) salary가 10000보다 크거나 같은 값이 있는 행만 찾는다
ORDER BY 급여;									-- 4) 급여의 오름차순 정렬
-- WHERE 급여 >= 10000;	별칭 사용 불가능(별칭은 select에서 만들어지나, where은 select보다 앞에서 읽힌다)
-- 19행
-- from -> where -> select -> order by

SELECT * FROM  employees;

-- 이름이 David인 사람의 이름과 급여만 조회하기
SELECT first_name, salary
FROM employees
WHERE first_name = 'David';
-- SQL은 기본적으로 대소문자를 구분하지 않지만 값(데이터)으로 들어갈 때는 대소문자를 구분한다!!

-- (4) 논리 연산자 (AND, OR, NOT)
-- 피연산자 자리에 조건이 온다
-- 여러개의 조건을 연결할 때 사용한다

-- employees 테이블에서 부서가 영업부서(80)이면서 급여가 10000 이상인 직원들의
-- 이름, 성, 급여, 부서ID를 급여 오름차순으로 조회
SELECT first_name 이름, last_name 성, salary 급여, department_id 부서ID
FROM EMPLOYEES
WHERE department_id = 80 AND salary >= 10000
ORDER BY salary;


/*
employees 테이블에서 직원의 이름이 Peter인 사람 중에
급여가 5000 이상인 직원들만 email 내림차순으로 조회
칼럼 전체 조회
*/

SELECT *
FROM EMPLOYEES
WHERE salary >= 5000 AND FIRST_NAME = 'Peter'
ORDER BY email DESC;

-- 테이블 : employees
-- 조건1 : first_name = 'Peter'
-- 조건2 : salary >= 5000
-- 정렬 기준 : email DESC
SELECT *
FROM EMPLOYEES
WHERE first_name = 'Peter' AND salary >= 5000
ORDER BY email DESC;

/*
실습 1 : 급여가 5000 이상이고 직무ID가 SA_MAN인 직원 조회
	직원의 이름과 성은 이름이라는 별칭으로 연결해서 출력하되 급여기준으로 오름차순 정렬되도록
	
실습 2 : 부서ID가 60이거나 급여가 4000 이하인 직원 조회
	직원의 이름, 전화번호, 입사일을 출력하되 입사일 기준으로 내림차순 정렬되도록
	
실습 3 : manager_id가 존재하지 않는 직원들을 조회
	직원의 이름과 성은 직원명이라는 별칭으로 연결해서 출력

*/

-- 실습 1. 급여가 5000 이상이고 직무ID가 SA_MAN인 직원 조회
--	직원의 이름과 성은 이름이라는 별칭으로 연결해서 출력하되 급여기준으로 오름차순 정렬되도록
-- 테이블 : salary, departmentID
SELECT first_name, last_name 이름
WHERE salary >= 5000 AND job_id = 'SA_MAN'
FROM employees
ORDER BY salary;











