-- 1번 : 집계함수

-- 집계함수의 결과는 행이 1개
-- NULL은 포함시키지 않는다!!!

-- COUNT()
SELECT * FROM EMPLOYEES;

-- 전체 직원수 확인
SELECT COUNT(*)
FROM EMPLOYEES;

-- 특정 부서 110번의 직원수 확인
SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES;

SELECT COUNT(*) AS "110번의 직원수"
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 110;

-- SUM()
-- 모든 직원의 급여 총합 계산
SELECT SUM(SALARY)
FROM EMPLOYEES;

-- 부서별 급여 총합 계산
SELECT DEPARTMENT_ID, SALARY
FROM EMPLOYEES;

SELECT DEPARTMENT_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;
-- GROUP BY : 그룹별로 묶기

-- AVG
-- 전체 직원의 평균 급여
SELECT AVG(SALARY)
FROM EMPLOYEES;
-- 실수형, 소수점 10째 자리까지 기본으로 나옴

-- 부서별 평균 급여
SELECT DEPARTMENT_ID, AVG(SALARY), SUM(SALARY), COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- MAX(), MIN()
SELECT MAX(SALARY), MIN(SALARY)
FROM EMPLOYEES;

-- NULL값은 제외됐음(포함되지 않음)을 확인
SELECT COUNT(COMMISSION_PCT), COUNT(NVL(COMMISSION_PCT, 0))
FROM EMPLOYEES;
-- NULL값을 제외하고 보고싶으면 NVL()함수를 사용!

-- 2. GROUP BY, HAVING
-- 평균 급여가 5000 이상인 부서 조회
SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
--WHERE AVG(SALARY) >= 5000 -- WHERE절에서 오류 발생, WHERE절에서 집계함수 사용불가!
GROUP BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) >= 5000;

-- 부서별 급여 총합이 50000보다 작은 부서들만 내림차순으로 정렬
SELECT DEPARTMENT_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, SUM(SALARY) 급여총합 
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID 
HAVING SUM(SALARY) < 50000
--ORDER BY DEPARTMENT_ID DESC;
ORDER BY 급여총합 DESC;

CREATE TABLE TBL_STU_G(
	STU_ID NUMBER,
	STU_NAME VARCHAR2(100) NOT NULL, --이름은 반드시 필요하니 NN 사용
	STU_PHONE VARCHAR2(100),
	STU_AGE NUMBER,
	STU_DEPT VARCHAR2(100),
	CONSTRAINT PK_STU_G PRIMARY KEY(STU_ID) --PK는 기본적으로 NOT NULL
);

SELECT * FROM TBL_STU_G;

INSERT INTO TBL_STU_G
--VALUES (1, '조승우', '8901-8888', 30, '교육학과');
--VALUES (2, '이동욱', '9012-9999', 30, '컴퓨터 공학과');
--VALUES (3, '김소현', '9876-1234', 20, '방송연예과');
--VALUES (4, '김남길', '5050-1222', 26, '컴퓨터 공학과');
--VALUES (5, '강하늘', '5111-5151', 22, '방송연예과');
--VALUES (6, '공유', '5050-5151', 30, '컴퓨터 공학과');
--VALUES (7, '이종혁', '1213-2222', 34, '방송연예과');
--VALUES (8, '박은빈', '1213-2222', 20, '방송연예과');

SELECT * FROM TBL_STU_G;

SELECT *
FROM TBL_STU_G;

-- 1) 학과 종류 검색

SELECT DISTINCT STU_DEPT
FROM TBL_STU_G;

-- 2) 각 학과별 학생수 조회

SELECT STU_DEPT 학과, COUNT(*) 학생수 
FROM TBL_STU_G
GROUP BY STU_DEPT;

-- 3) 각 학과별 평균나이 조회
-- ROUND(컬럼값, 소수점몇자리까지) 3자리에서 반올림
SELECT STU_DEPT 학과, ROUND(AVG(STU_AGE), 2) 평균나이
FROM TBL_STU_G
GROUP BY STU_DEPT;

-- 4) 학과별로 26살 이상인 학생만 전체 컬럼 조회(별칭 : 이름, 핸드폰번호, 나이, 학과)
-- 전체가 아니라 학생 수만 나와야하기에, 지금까지 배운거로는 나타내는게 불가능함, 서브쿼리를 배운 이후에 가능
-- 아래꺼는 출력이 되긴하나, 문제가 원하는 형식이 아님
SELECT STU_NAME 이름, STU_PHONE 핸드폰번호, STU_AGE 나이, STU_DEPT 학과
FROM TBL_STU_G
WHERE STU_AGE >= 26
ORDER BY STU_DEPT;

-- 학생 수만 보여주기
SELECT STU_DEPT 학과, COUNT(*) 학생수
FROM TBL_STU_G
WHERE STU_AGE >= 26
-- 학과별로 그룹핑
GROUP BY STU_DEPT;

-- 5) 학생이름이 김으로 시작하거나 이로 시작하는 학생들의 학과별 수 조회

SELECT STU_DEPT 학과, COUNT(*) 학생수
FROM TBL_STU_G
WHERE STU_NAME LIKE '김%' OR STU_NAME LIKE '이%'
GROUP BY STU_DEPT;

-- 6) 컴퓨터 공학과의 학생 중 25살 이상인 학생수 조회

SELECT COUNT(*) AS "25살이상인 학생수"
FROM TBL_STU_G
WHERE STU_DEPT='컴퓨터 공학과' AND STU_AGE >= 25;
-- 별칭은 30자 이하
-- 13글자이지만 UFT-8 2~3바이트 처리 제한 초과(오라클에서 자주 발생)

-- 3. ROWNUM
SELECT ROWNUM, E.* FROM EMPLOYEES E;
-- EMPLOYEES 컬럼 가장 앞쪽에 숫자가 생김!

SELECT ROWNUM, SALARY FROM EMPLOYEES;
-- 급여 앞에 숫자가 붙어서 나옴

-- EMPLOYEES 테이블에서 SALARY를 내림차순으로 정렬한 뒤 ROWNUM을 붙여서 조회하기

SELECT ROWNUM, SALARY		-- 2) 컬럼을 조회한다
FROM EMPLOYEES				-- 1) 테이블에서
ORDER BY SALARY DESC;		-- 3) 급여 내림차순으로
-- 서브쿼리 사용으로 ROWNUM을 내림차순 정렬 가능

--SELECT ROWNUM, E2.*
SELECT ROWNUM, E2.SALARY
FROM (SELECT * FROM EMPLOYEES E ORDER BY SALARY DESC) E2;

-- 급여가 1위 ~ 5위까지 조회

SELECT ROWNUM, E2.SALARY
FROM (SELECT * FROM EMPLOYEES E ORDER BY SALARY DESC) E2
ORDER BY ROWNUM = 5;



































