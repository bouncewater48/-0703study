day12_개념 (java 10일차)
복습 -> static 블록 -> 변수의 종류 -> enum -> git hub -> 팀과제

0. 복습
1) 클래스
	필드, 메소드, 생성자

	public(대표클래스) class 클래스명{
				//멤버 (필드 + 메소드)
				//필드, 메소드, 생성자
	}

2) 객체화(인스턴스화)
	클래스자료형 참조변수 = new생성자();
	--------------	 ----------
	Stack 영역	 Heap 영역

3) 클래스 멤버 접근
	객체명.필드명
	객체명.메소드명();

4) static(정적)
	method 영역	=> 프로그램 시작부터 종료까지 계속 남아있는 영역
	정적 변수 : static변수, 클래스 변수
	정적메소드 : static 메소드, 클래스 메소드
	상수 선언이 가능하나, 지역변수이기에 해당메소드 안에서만 사용이 가능하다	
	
	클래스명.정적변수;
	클래스명.메소드명();
			
5) 클래스
	class 클래스명 {
		//필드
		//인스턴스 변수(객체마다 고려한 값)
		//스태틱 변수(모든 객체가 통일된 명령만 사용)
		//상수

		//메소드
		//인스턴스 메소드
		//스태틱 메소드
		
		//셍성자
		//기본생성자
		public 클래스명(){
		(super 출력된건 지우고 사용)

		}
		
		publc 클래스명(int num){
			this.num = num1;
			int result = num1 + 10; (생성될때 사용가능)
			(result가 지역변수로 사용될 경우, 메인메소드에 .result로 출력하면 0만 출력!!)
		}
		
		public 클래스명(int num1, int num2){
			this(num1); //this : 자기자신의 생성자 호출
			this.num2 =num2;
		}

	}
	
6) this, this()
	this : 객체 자기자신(참조값)
	this() : 자기자신의 생성자
	
7) 다형성 => 오버로딩
	같은 메소드명, 생성자로 매개변수의 타입, 개수, 순수가 다르면 선언할 수 있다	
	리턴타입은 영향을 끼치지 않는다	
	
	
1. 스태틱 블록(정적 블록)(DB 배울때 쓰니까 꼭 알아둘것)
	클래스가 로드될떄 싱행되는 블록
	주로 정적멤버를 초기화 하는 데 사용된다
	모든 인스턴스가 생성되기 전에 실행되므로 초기화 작업에 유용하다

	로드시점 : 클래스가 처음 로드될 때 실행된다
		- 클래스의 객체가 생성될 때(클래스 인스턴스화)
		- 클래스의 정적멤버(스태틱변수, 스태틱메소드)에 접근할 때
		- 클래스를 사용하는 다른 클래스가 로드될 때(참조하려는 클래스에 의존성이 있는 경우)



2. final(변수,메소드,클래스 모두 사용가능)

	final이 붙은 변수는 상수이다(더이상 값 변경 불가)
	final 변수	상수(값변경불가)
	final 메소드	오버라이딩 불가(재정의 불가)
	final 클래스	상속불가

3. emum 열거형 (상수랑 관계가 있음) (Http코딩에 쓰임, 웹개발에서 활용도가 높음)
	일련의 고정된 값(상수)들을 나타내기 위한 특별한 데이터 유형(클래스)
	클래스 타입(reference type)으로 취급된다

1) enum 사용하는 이유 
	코드의 가독성과 안정성
	컴파일 타임 오류 방지
	관련 데이터와 동작을 묶을 수 있음


2) 문법
	enum Day{ //Day 대문자로 작성한건 = 클래스임
		MONDAY, TUESDAY, WEDSEDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
		//클래스 내부에 있는건 하나하나가 객체
	}



3) 특징
	enum에 선언된 값은 상수 객체로, 각 값은 컴파일 시점에 고유한 인스턴스로 생성된다
	값의 순서는 0부터 시작하며 순서를 정수로 얻으려면 ordinal() 메소드를 사용한다
	필드, 메소드, 클래스 다 들어갈 수 있다

	열거형 배열
		values() 모든 열거형 값을 배열로 얻을 수 있다
	name(), valueOf()
		name() : 열거형 이름(문자열)을 반환
		valueOf(문자열) : 문자열을 열거형으로 반환

4. 변수의 종류
	종류		선언위치/특징			메모리영역		수명
	
	상수		Final키워드, 값 수정 불가능		상수 풀/Stack	블록/클래스 종료시까지 유지
	
	지역변수		메소드나 블록내에서 선언		Stack		메소드 종료 시 소멸
			외부에서 접근 불가능								
	
	매개변수		메소드 선언 시 전달값을 받기위한 변수	Stack		메소드 실행 중 유지	
	
	인스턴스변수	클래스 내부에서 선언			Heap		객체가 살아있는 동안 유지
			객체마다 별도로 존재(객체명.인스턴스변수명)						
	
	정적변수		static 키워드			메소드		프로그램 시작부터 종료까지	
			클래스 로딩 시 하나만 생성	


5. git-hub
1).gitignore 파일
	git이 버전관리에서 무시할 파일이나 디렉터리를 지정하는데 사용한다
	git에게 이 파일이나 폴더는 추적하지 않도록 알려주는 설정파일
	
# 클래스 파일
*.class

# 로그 파일
*.log

# 빌드 폴더
/build/
/target/

# IDE 설정 (Eclipse, IntelliJ 등)
*.iml
.idea/
.project
.classpath

# OS 관련 파일
.DS_Store
Thumbs.db

# 환경 설정
.env

https://github.com/github/gitignore
이그노어 코드들이 다 올라와있는 링크, 여기서 검색해서 그대로 복붙하면 끝

https://www.toptal.com/developers/gitignore
이그노어 코드를 원하는 설정에 맞게 자동생성해주는 링크
>> 여기서 코드 받아서 메모장으로 저장할때, 
항상 인코딩 타입은 UTF-8로 고정 & 파일형식은 모든파일로 고정
※인코딩 타입이 다르면 다른데서 못 열음

https://github.com/bouncewater48/kdt_java.git

팀장 => 레포지토리
	팀원 초대 => 팀원 이메일 확인
	
team_pro1 파일을 제외하고 다 ignore 시키고 올리기
혹은 team_pro1 파일을 들어가서 git init을 해도 됨

무조건 팀장이 git bash를 한 폴더에서 똑같이 열어야함
똑같이 안하면 pull 받을때 충돌남

깃허브에 아래 내용 작성시
echo "# team_pro1" >> README.md 
README.md 파일 생성


[팀장]
1. GIT-HUB 레포지토리 만들기
2. 폴더 구조(패키지, 클래스 등 만들기)
	- 메소드 위치 선정(주석으로)
	- gitignore 파일
	- readme.md 파일
		문제
		이름 - 기능 구현 내용
3. main브랜치에서 커밋 -> github 레포지토리로 push
4. 팀원에게 클론따라고 말하기
5. 개인 브랜치 생성

[팀원]
1. 폴더구조 확인 후 클론
2. 개인 브랜치 생성
3. 본인이 만들어야하는 메소드 확인





git clone [주소]

git checkout -b ksh
switched to a new branch 'ksh'



	// checkAnswer() 강승훈 : 정답비교
	 boolean checkAnswer() {
	      if (this.input == this.answer) {
	         System.out.println("정답입니다!!");
	         return true;
	      } else {
	         System.out.println("틀렸습니다!!");
	         return false;
	      }
	   }
	
	
	마스터 브랜치 > 메인 브랜치 변경
add origin [Git-hub 링크]
파일 pull 받기
개인 브랜치 생성, 브랜치 이동
개인 브랜치로 메인 브랜치 merge
개인작업 및 파일 수정
commit
status / log 확인
개인브랜치에서 깃허브로 origin push
push해서 pr창이 뜬걸 확인하고, pr

	
	






























