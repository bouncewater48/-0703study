day06(java 4일차)
복습 -> 연산자2 -> 제어문(조건문)

0. 복습
1) JAVA
	1995년 공식 발표
	sun 마이크로시스템사 제임스 고슬링팀 개발

	객체지향언어
	플랫폼 독립성
	자동 메모리 관리

2) 변수
	하나의 자료형, 하나의 값을 저장할 수 있는 저장공간
	자료형 변수명 = 값;

3) 입출력 메소드

	출력메소드
	System.out.println();
	System.out.print();
	System.out.printf();

	입력메소드를 사용하기 위해서는 입력클래스가 반드시 필요하다
	Scanner sc = new Scanner(System.in); //왼쪽이 저장공간, 왼쪽에 다 저장가능
	Scanner 클래스는 java.util 패키지 안에 있기 때문에 반드시 import 받아와야한다

	입력메소드
	.next();
	.nextLine();
	.nextInt();
	.nextDouble();

4) 연산자의 우선순위
	최우선		위에서 아래순으로 우선순위가 내려감!
	단항
	산술
	쉬프트
	관계
	논리
	삼항
	대입

5) 산술 연산자
	+, -, *, /, %

6) 증감연산자
	단항연산자
	++, -- (연산자 앞에 있으면 전위연산자, 뒤에 있으면 후위연산자)

	int num1 = 5, num2 = 5;
	int x, y;
	x = num1++;
	syso(x)		//5
	syso(num1)	//6 (후위연산이라 아랫줄에서만 ++이 계산된다)

	num2 += num1--;	//num2 = num2 + num1--;
	num1 => 5	//num2 =  5   +  6(아직 계산 안됨)
	num2 => 11	//num2 =  5   +  6(윗줄꺼 후위라서 지금 계산!)

1. 관계연산자(우선순위 5)(비교연산자)
	조건식	결과가 참 또는 거짓, 둘 중 하나가 나오는 식(boolean타입으로 결과가 나온다)
	boolean 타입이라 항상 true 혹은 false 만 출력됨

	>, <	초과  미만 
	>=, <=	이상  이하
	==, !=	같다  같지않다

	a > b	a가 b보다 크니? 맞으면 true, 틀리면 false
	a < b	a가 b보다 작니? 맞으면 true, 틀리면 false
	a >= b	a가 b보다 크거나 같니? 맞으면 true, 틀리면 false
	a <= b	a가 b보다 작거나 같니? 맞으면 true, 틀리면 false
	a == b	a가 b랑 같니? 맞으면 true, 틀리면 false
	a != b	a가 b랑 다르니? 맞으면 true, 틀리면 false

2. 논리연산자
	and	: 두 조건식이 모두 참이면 참			&&
	or	: 두 조건식 중 하나라도 참이면 참		||
	not	: 조건식이 참이면 거짓으로, 거짓이면 참으로		!true
	
	true && true
	true || false
	!true
		
	티켓등에 쓰이는 ~세부터 ~까지 같은 비교형도 논리연산자를 사용하는것
	
3. 삼항연산자(?:)
	조건식? 참일때의 값 : 거짓일때의 값
	연산자	연산자	 연산자
	변수에 저장할 수 있고 출력도 가능핟

	거짓일 때의 값에 삼항연산자를 한 번 더 작성하면 삼항연산자의 중첩으로 3개의 값을 출력할 수 있다
	
4. 비트연산자
1) 비트와 바이트의 개념
비트(bit)		
	정보의 최소 단위
	한 비트는 0, 1 두가지의 값만 표현할 수 있다
	ex) 스위치(켜짐/꺼짐), 참/거짓
	
바이트(byte)
	8개의 비트를 묶어서 1byte라고 부른다
	문자 1개 = 2byte(유니코드 기준)
	ex) 영어 문자 A -> 01000001 (1byte)
			자바에서 실제로는 2byte를 사용함!
	
왜 비트 단위로 연산할까?	
	사람이 쓰는 고급언어는 컴퓨터 언어(저급언어)로 바꾸는 과정이 반드시 필요한데,
	비트 단위로 연산하면 생략이 가능해져서 연산 속도가 상당히 향상되므로 연산을 하는것.
	
2) 비트연산자
	AND(&)	논리곱
		두 비트가 모두 1이면 1, 아니면 0 (true&false가 1&0으로 출력되는거라 생각!)
		비트 연산은 해당 숫자를 나눗셈했을때의 나머지(몫)을 아래부터 반대로 읽어서 나오고,
		byte가 안맞다면 앞에 그만큼 0이 있다 봄
		십진수 10 -> 이진수 변환하면 1010(2)(이진수라는 표현, 실제로는 옆이 아닌 아래에 표기됨)
		십진수 11 -> 이진수 변환하면 1011	
				이진수 변환은 해당 숫자를 2로 나누는것			


	10 ->	1010
	11 -> & 1011
		======	
		1010

	OR(|) 	논리합	
		두 비트 중 하나라도 1이면 1

	10 ->	1010
	11 -> & 1011
		======	
		1011



	XOR(^)	베타논리합
		두 비트가 서로 다르면 1

	10 ->	1010
	11 ->	1011
		=======
		0001

	NOT(~)	논리부정
		비트가 0이면 1로, 1이면 0으로
		부호비트 또한 반대로 바꿔줌(양수 -> 음수, 음수 -> 양수)
		부호비트가 바뀔때 음수로 바뀌어도 컴퓨터는 음수(뺄셈)를 표현하지 못함 (	

		~n  => -(n+1) < 이해하려하지말고 그냥 공식 외우기
		~10 => -11
				
	00001010	=> 10
	    0101	<= 5로 예상하지만 결과는 -11로 나온다 / 반대니까 논리부정형으로 생각
	========
	11110101	=> -11

	2의 보수 형식으로 음수를 표현하면
	00001010
+	       1
	========
	00001011		=> 11
	
	=> 10이라는 10진수는 2진수로 1010(2)가 된다(몫이 1이 나올때까지 2로 계속 나누면 된다)
		~1010:	0101(2)로 바껴서 5가 나올거라 예상하지만 결과는 -11로 나온다
	
	(증명) 컴퓨터는 덧셈만 가능하기 때문에 뺄셈을 구현하려면 음수가 필요하다
		비트 중 가장 앞에 있는 비트를 최상위 비트라고 한다. 최상위 비트는 부호비트로 사용된다(0:양수, 1:음수)

		1010으로 쓴 양의 정수 10은 앞에 부호비트 01010인것이다
		~01010 => 부호비트가 1로 바뀌기 때문에 일단 음수로 변환이 된다
	
		반전된 2진수  : 11110101 (0이랑 1이 서로 바껴서 앞에 채워졌던 0이 1로 바뀜)
		2의 보수	  :  00001010  
		+1 추가	  :  00001011 
	
+) 1의 보수 : 이진수의 모든 비트를 반전시켜서 구한다 (1 -> 0, 0 -> 1)
	음수를 표현하기 위해 사용되었지만 지금은 2의 보수가 더 많이 사용된다

	양수 5	=> 0101
	1의 보수	=> 1010	
	
	음수 표현	: -x => x의 1의 보수
	0000	양수 0	
	1111	음수 -0

++) 2의 보수 : 1의 보수 + 1로 계산된다

	양수 5	=> 0101
	1의 보수	=> 1010
	2의 보수	=> 1010 + 1 => 1011 (2/2=1의 몫을 더함)
	
	음수표현	: -x => x의 2의 보수
	0은 유일한 형태로 존재 0000
	
	
3) 쉬프트 연산자 (이동한다)	
좌쉬프트 A << B : A의 비트를 왼쪽으로 B만큼 이동시킨다
	비트를 왼쪽으로 이동시키고 오른쪽에 남은 빈 공간은 0으로 채워진다
	지정된 비트수를 넘어가면 잘리게된다
	ex) 5 << 1 	=> 0101 -> 1010  = 10 / 왼쪽으로 한번 이동하면 숫자가 2배로 증가
	    5 << 2	=> 0101 -> 10100 = 20
	1011


우쉬프트 A >> B : A의 비트를 오른쪽으로 B만큼 이동시킨다
	왼쪽에 생기는 빈칸은 부호비트에 따라 달라진다(양수 0으로 채워지고 음수면 1로 채워진다)
	이동 중 지정된 비트수를 넘어가서 날린 비트는 잘리게 된다
	ex) 8 >> 1	=> 1000[8] -> 100[4] / 오른쪽으로 한번 이동하면 숫자가 2배로 감소
	    8 >> 2	=> 10[2]
	
+) 암호화와 복호화
	데이터를 안전하게 전송하거나 저장하기 위한 과정

1) 암호화
	원본 데이터가 있을때 변형하여 외부에서 알아보기 어려운 형태로 만드는 과정
	특정 알고리즘과 키를 사용하여 원본 데이터를 암호화
	결과로 나온 암호문은 원본 데이터와는 다른 형태의 데이터이며, 키를 알지 못하는 한 해독하기 어렵다
	(해독을 하려면 할 수 있다)

2) 복호화
	암호화 된 데이터를 다시 원래의 형태로 되돌리는 과정
	암호화할 때 사용한 알고리즘과 동일한 키를 사용하여 암호화된 데이터를 해독하여 사용가능
	복호화된 결과는 원본 데이터로 복원

+) 대칭키와 비대칭키
1) 대칭키
	대칭키 암호화는 하나의 키를 사용하여 데이터를 암호화하고 복호화하는 방법
	a라는 문자를 암호화 : korea key 보내는 사람
	대칭키 암호화는 속도가 빠르고 효율적이며, 대부분의 일상적인 데이터 보호 작업에 사용

	받는 사람 korea key 키 (보내는 사람, 받는 사람 둘 다 동일한 korea 키를 가지고 있어야한다.)

2) 비대칭키
	두 개의 서로 다른 키(공개키와 개인키)를 사용하여 데이터를 암호화하고 복호화하는 방법
	공개키는 누구나 알 수 있는 키이며 개인키는 소유만 알고있어야하는 비밀 키
	데이터를 공개키로 암호화하면 개인키로만 복호화할 수 있으며, 개인키로 암호화된 데이터는 공개키로만 복호화 할 수 있다
	ex) 디지털 서명
	데이터의 안전한 전송과 디지털 서명에 사용


5. 제어문1
	프로그램의 흐름을 제어한다
	
	조건문	조건식의 결과에 따라서 실행흐름을 결정한다
		if문(if, if~else, if~else if~else), switch문
		if~else : 조건문의 분기를 나누는 분기점 역할	
		
	반복문	특정 조건을 만족할 때까지 실행 코드를 반복 실행한다
		for문, while문, do~while문

	기타제어문	흐름을 건너뛰거나 즉시 종료한다
		break문, continue문
	
	
6. 조건문
1) if문
	조건식의 결과가 true이면 중괄호 영역 안으로 들어가서 문장을 실행하고 다음 코드를 순차적으로 실행한다	
	조건식의 결과가 false라면 중괄호 영역 안으로 들어가지 않고 바로 다음 코드를 순차적으로 실행한다	
*문법	
	if (조건식) { //조건식이 거짓이라면 {} 자체가 실행되지 않음
		조건식이 참일때 실행할 문장;
	}
	조건식이 true면 실행할 문장 실행 후에 순차적으로 실행된다
	조건식이 false며 if문 중괄호 안의 내용을 실행하지 않고 이 다음 문장들이 순차적으로 실행된다
	
	
2) if ~ else문
	조건식의 결과가 true, false 각각의 분기를 만들어서 해당 중괄호 영역안으로 들어가 문장을 실행한다		
		
*문법		
	if(조건식){		
		조건식이 true일 때 실행할 문장;
	}else{ else는 true가 아닌게 와서 실행되므로 딱히 다른 조건을 추가할 이유가 없음
	  	조건식이 false일 때 실행할 문장;
	}


3) if ~ else if ~ else문
	조건식1의 결과가 true라면 if문 중괄호 영역 안의 문장을 실행
	조건식1의 결과가 false라면 else if문의 조건식2를 확인한다
	조건식2의 결과가 true라면 else if문 중괄호 영역안의 문장을 실행
	조건식2의 결과가 모두 false라면 else문 중괄호 영역 안의 문장 실행

*문법
	if (조건식1){
		조건식1이 true일 때 실행할 문장;
	} else if (조건식2){
		조건식1이 false이고 조건식2가 true일 때 실행할 문장;
	} else {
		조건식1과 조건식2의 결과가 false일 때 실행할 문장;
	}


- if문	: 조건문을 사용할 때 반드시 있어야한다
- else if문 : 확인해야하는 조건식이 2개 이상일 경우 작성한다
	     else if문은 여러개가 있어도 작동한다 
- else문 : 위의 조건식 모두 거짓일 때 실행할 문장을 작성한다

※ if~if문, if~else if문
	if~if문은 모든 조건식을 확인한다
	if~else if문은 if문의 조건식을 확인 한 뒤 true라면 아래 문장은 스킵한다



	int num = 10;
	if(num == 10){
		syso(num);
	}
	if(num > 5){
		syso("num은 5보다 큽니다");
	}


	if(num >= 90){
		(if num == 100){
			syso(num);
		}else{
			syso(A);
	else if(num > 90){
		syso("num은 5보다 큽니다");
	}



	위의 두개 다 if문은 출력되고, if~if문은 아래 조건식까지 같이 출력하지만 if~else if문은 아래 조건식은 출력하지 않음


※ if문의 중첩
	if문 안에 if문이 있는것을 의미한다
	if(조건식){
		if(조건식2){
			조건식1과 조건식2가 모두 true 실행할문장;
		}else{
		       조건식1만 true일 때 실행할 문장;
   }


4) switch문
	조건식의 값에 따라 여러 case 중 하나를 실행한다
	
	switch (변수명 or 값){
		case 값1:
			값1일 때 실행문;
			break;
		case 값2:
			값2일 때 실행문;
			break;
		case 값3:
			값3일 때 실행문;
			break;
		...
		default:
			위 값들에 해당하지 않을 때 실행문;
			break
	}

- switch문에서 사용할 수 있는 변수 타입 : byte, short, int, char, String, enum
- 사용할 수 없는 변수 타입 : long, float, double, boolean

+) 삼항연산자, if문, switch문
- 삼항연산자 : 조건식이 1개만 있을 경우
- if문 : 조건식에 논리연산자를 사용하거나 조건식이 2개 이상인 경우
- switch문 : 하나의 변수에 여러개의 값이 담길 수 있고 case의 값과 같은지를 비교해야할 때 사용


코인 노래방 프로그램

한 곡당 300원인 코인노래방이다. 사용자에게 금액을 입력받고 부를 수 있는 곡 수, 잔 돈을 출력
금액입력 : 1000
[출력]
3곡을 부를 수 있으며 잔돈은 100원입니다

클래스명 : SingTask01(1,2번 같이 묶기)
1) 한 곡당 금액도 입력받기
금액입력 : 1000
곡 당 가격 입력 : 300
[출력]
3곡을 부를 수 있으며 잔돈은 100원입니다

2) 잔돈이 부족할 경우 안내하기
금액입력 : 100
곡 당 가격 입력 :
[출력]
입력한 금액은 100원입니다. 곡 당 가격은 000원으로 000원이 부족하여 노래를 부를 수 없습니다 출력

클래스명 : SingTask02
3) 남은 금액으로 음료 구매 가능 여부 추가(한 곡당 금액 200원, 음료 금액은 100원)(음료는 무조건 1잔만 가능)
금액입력 : 1000원
[출력]
5곡을 부를 수 있으며 잔돈은 0원입니다
음료를 마시고 싶으면 4곡을 부를 수 있으며 잔돈은 100원입니다

클래스명 : SingTask03
4) 총 부른 곡 수에 따른 보너스 곡 지급
5곡을 부르면 1곡 추가 제공
(6일차에 배운 내용만 사용)








