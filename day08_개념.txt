day08(java 6일차)
복습 -> 이중 for문 -> 배열 -> 이차원 배열 -> 메소드

0. 복습
1) 제어문
	조건문	if문, switch문
	반복문	for문, while문, do~while문
	기타제어문	break문, continue문

2) if문
	if (조건식) {
		조건식1이 true일 때 실행할 문장;
	} else if (조건식2) {
		조건식1이 false고, 조건식2가 true 일때 실행할 문장;
	} else {
		조건식1과 조건식2가 모두 false일 때 실행할 문장;
	}

3) swicth문 
	switch문 (변수) {
	case 값1 : 
		값1과 같을 때 실행할 문장
		break문; (break문 미작성시 무한루프가 됨)
	case 값2 : 
		값2와 같을 때 실행할 문장;
		break문;
	case 값3 :
		값3과 같을 때 실행할 문장;
		break;
	default : 
		위의 값들과 일치하지 않을 때 실행할 문장;
		break;
	}


- 삼항연산자	: 값을 저장하거나 출력할 때 / 조건이 1개일 때
- if문		: 논리 연산자가 사용되거나 조건이 2개 이상일 때;
- switch문	: 하나의 변수에 여러 값이 들어갈 수 있을 때;

4) for문
	반복 횟수가 정해져 있을 때
	for (초기값; 조건식; 증감식){ //초기값 - 조건식 - 증감식 - 반복실행문 - 조건식 - 증감식 - 				   반복문...으로 조건식이 false가 출력될때까지 진행
		반복실행할 문장;
	}
	

5) while문
	조건을 만족하는 경우 반복
	//조건식이 false가 되는 문장 필수구성!
	//조건식 비교대상변수
	while(조건식) { 
		반복실행할 문장; //while문은 조건을 달면 무한반복됨, 따라서 비교대상변수로 조건만족을 추가
	}

6) do~while문
	조건과 상관없이 무조건 1번은 실행, 그 이후 조건을 만족하는 경우 반복
	do{
		반복실행할 문장;
	} while(조건식);

7) break;
	반복문/조건문 즉시 탈출 (아래내용 출력 X)

8) continue문
	반복문의 다음 반복으로 건너뛰기 (아래내용 출력 X)

	
1. 이중 for문
	이중 for문은 하나의 for문 안에 또 다른 for 문이 들어있는 구조
	반복적인 작업을 가로(행), 세로(열) 방향으로 수행할 때 사용한다.

	for(초기식; 조건식; 증감식) [ //바깥 for문
		for(초기식2; 조건식2; 증감식) { //안쪽 for문
			반복실행할 문장; // {}안에는 반복실행할 문장 하나는 반드시필요, 없으면 오류
				     // 이 부분에는 반드시 코드가 작성되어야한다
		}
		
	}			


1) 동작원리
	바깥 for문이 한 번 실행되면
	안쪽 for문은 조건이 false가 될 떄까지 계속 반복된다
	안쪽 for문이 끝나면 바깥 for문이 다시 한 번 반복되고
	그때마다 안 쪽 for문 다시 처음부터 시작한다

※ 구구단 만들기

1) 단별로 세로로 


2. 배열

1) 배열(Array)을 사용하는 이유
	저장공간이 나열되어있는 것을 의미
	변수 => 하나의 타입으로 하나의 값만 저장할 수 있는 저장공간

	변수를 여러개 선언하면 이름도 여러개 생긴다 => 각 저장공간을 관리하기가 불편해진다
	n칸짜리 배열을 선언하면 저장공간이 여러개 생기고 이름은 하나로 생긴다 => 관리가 용이해진다
	규칙성이 없는 값에 규칙성을 부여하기 위해서(index) 배열을 사용하기도 한다
	배열의 저장공간은 모두 다 붙어있다

	변수[]		하나의 타입으로 된 하나의 값만 저장할 수 있는 저장공간
	배열[][][]	하나의 타입으로 된 여러 값을 저장할 수 있는 저장공간의 나열
	배열[]에는 정수(int)만 들어갈 수 있다


2) 배열의 선언
	변수선언	자료형 변수명 = 값;

- 배열변수를 선언 후 배열 생성
  어떤 값을 넣을 지 모르나 몇 칸을 만들지는 알 때 사용

	자료형[] 배열이름 = new 자료형[배열크기];
	ex) int[] ar1 = new int[5];	//어떤 값을 넣을지는 모르지만 5칸짜리 배열을 선언했다

- 배열 변수 선언과 함께 초기값 할당
  어떤 값을 넣을 지 알 때 사용
	
	자료형[] 배열명 = {값1, 값2, 값3, 값4}; //4칸짜리 배열을 선언하고 저장했다
	ex) int[] ar2 = {100. 50, 63, 87);

- 배열을 생성하지 않고 배열 변수를 초기화
  어떤 값을 넣을지도 모르고, 몇 칸 짜리로 만들어야할지도 모를 때

	자료형[] 배열명 = null;
	ex) int[] ar3 = null;

- 배열 변수에 배열 생성과 초기화
	
	배열명 = new 자료형[]{값1, 값2, 값3};
	ex) ar3 = new int[]{1, 2, 3};
	//RAM 안에 ar3라는 값과 크기를 저장함



3) new 연산자 ★★★★
	Heap메모리에 할당(new연산자는 무조건 여기에 할당됨)(new = Heap 메모리로 기억할것)
	저장공간의 시작주소를 가져온다
	
   null 주소의 초기값(어떤 주소가 들어갈 지 모를 때 사용)

   자바에서 배열은 항상 Heap(동적 메모리)에 할당되기 때문에 메모리 상에서 동적배열만 존재한다
			=메모리가 시작됐을때 만들어지는게 아니고(프로그램이 시작됐을때), 우리가 직접 만들었을때 그때 같이 만들어진다 / 처음부터 올라가있는게 아니라 우리가 배열을 만들었을때 올라가는것

	Scanner sc = new Scanner(System.in)
			참조값 변수


+) Runtime Data Area : JVM이 관리하는 프로그램을 실행하는 동안 사용하는 메모리 영역
	JVM의 메모리 영역은 OS(운영체제)에게 할당받은 메모리이다.
운영체제로부터 할당받은 메모리 공간 내에서 독자적으로 메모리를 관리하고 이를 여러 영역으로 나누어 사용한다
	따라서 JVM의 메모리 영역은 운영체제의 메모리리 영역과는 분리되어 동작된다
	크게 5개의 영역으로 구분되며 힙영역, 스택영역, 메소드영역, 프로그램 카운터 레지스터, 네이티브 메소드스택


- 힙 영역(Heap Area) << new 연산자는 거의 다 이곳에 저장된다
	객체와 배열이 생성되는 메모리 공간
	new라는 연산자로 생성되는 객체나 배열이 할당
	동적 메모리 할당을 사용하기 때문에 프로그램이 실행중에 메모리의 크기를 동적으로 조정할 수 있다
	
- 스택 영역(Stack Area)
	메소드 호출(불러온다, 사용) 시에 사용하는 메모리 공간ㄴ
	메소드가 호출될 때마다 스택에 새로운 프레임이 생성되며 메소드 종료시에는 해당 프레임이 제거된다
	각 쓰레드마다 별도의 스택 영역을 가지며 동시에 여러 메소드가 호출될 수 있다
	(입력, 출력 메소드 등)

- 메소드 영역(Method Area)
	클래스의 정보, static 변수. 상수 등이 저장되는 메모리 공간
	메소드 영역 JVM이 시작될 때 생성되며, 모든 쓰레드가 공유한다

- 프로그램 카운터 레지스터(PC Register)
	프로그램 카운터 레지스터는 현재 실행중인 명령어의 주소를 저장하는 메모리 공간
	JVM이 쓰레드를 생성할 때마다 별도의 PC Register를 가진다

- 네이티브 메소드 스택(Native Method Stack)
	JNI(Java Native Interface)를 사용하여 호출되는 C/C++ 메소드의 스택영역이다


-----------------------------------------------------------------------------
4) 배열의 구조
	
	ar은 변수가 아니라 시작주소값만 저장하는 참조변수임
	
	int[] ar 		= 		new int[]{7, 9, 1, 2, 4}:
	-------      		대입 연산자	--------------------------
	Stack 메모리				Heap 메모리에 저장된 시작 주소값
	정수형배열 ar 참조 변수			5칸짜리 정수형 배열을 만들고 값이 저장되어 있다
	
	ar이라는 이름의 변수는 배열 객체의 주소값을 가리키는 참조변수이다
	배열 객체는 Heap 영역에 할당되며, 배열 객체 안에는 여러개의 값이 담길 수 있다..
	따라서 ar 변수는 배열 객체의 주소값을 가리키고 해당 배열 객체 안에 여러 값을 가질 수 있다.
	
	ar 이름의 저장공간 1개, 여러개의 값이 담길 수 있다
	5개의 값을 담기 위해서는 5칸이 필요하고, Heap메모리에 저장된다
	
	[Stack]		[Heap]

	|  ar  |------->|_[8][2][1]_|
	
	참조변수		배열객체



5) Index
	배열을 생성할 때 각각의 저장공간에 자동으로 붙혀지는 번호
	0부터 순차적으로 증가하면서 부여된다
	배열의 이름이 한개이기 때문에 이름만으로는 배열의 여러 저장공간에 접근 할 수 없다
	그렇기 때문에 Index를 이용하여 각각의 저장공간에 접근한다
	배열명 [int Index]으로 사용하고 참조변수[Index]는 하나의 저장공간이기 때문에 변수처럼 사용한다

6) length
	배열을 생성할 때 자동으로 생성되는 저장공간의 수(배열의 길이)
	배열의 길이는 한 번 만들어지면 변동될 수 없으므로 length는 상수라고 볼 수 있다
	배열명.length로 사용하게 된다


7) 배열의 사용
	배열명[index]
	
	int[] ar = {5, 2, 1, 8};
	syso(ar);	//배열의 시작주소값(참조값)

	
	String[] ar = new String[2]; //class타입에는 객체가 반드시 만들어져야하고, 이는 주소값을 지님
	syso(ar[1]); // null
	
	
	
	
	
	

---------------------------------------------------------------------------------------
개인메모	
	변수를 배울 때 저장공간 = 고유한 주소값 으로 배웠었음

	자료형[] 참조변수 = new 자료형[칸수]; => 저장공간을 만든다. 해당 저장공간 시작주소값을 가져오는 역할
	new _____ < 저장공간을 새로 만들고, 해당 저장공간 주소값을 가져오는 역할을 함
	해당 주소값은 '자료형[] 배열명 = new 자료형[칸수]' / 자료형[칸수]에 가져오고, 이를 배열명에 저장함
	
	저장공간(변수)이 만들어질때마다 해당 변수는 각각의 주소를 가지게 됨(RAM에)
	RAM 메모리 자체가 랜덤한 곳에 저장시키기에 위치를 알 수 없음.
	이를 참조변수로 가져오는것
	참조변수로 가져올때는 항상 해당 메모리의 시작주소값(0번째 주소)에 저장해서 가져옴!
	
----------------------------------------------------------------------------------------






























