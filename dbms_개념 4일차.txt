day22 (dbms 4일차) 개념
복습 -> 제약조건 -> 무결성 -> 모델링 -> 정규화

0. 복습
1) DML 데이터 조작어
- 데이터 조회
   SELECT [DISTINCT] 컬럼명 [AS 별칭]
   FROM 테이블명
   [WHERE 조건식]
   [ORDER BY 정렬할컬럼 ASC or DESC]

- 데이터 추가(삽입)
   INSERT INTO 테이블명(컬럼명)
   VALUES (값1, 값2, ..);

- 데이터 삭제
   DELETE FROM 테이블명
   [WHERE 조건식];

- 데이터 수정
   UPDATE 테이블명
   SET 컬럼명 = 값
   [WHERE 조건식];

2) DDL 데이터 정의어
- 테이블 생성
   CREATE TABLE 테이블명(
      컬럼명 자료형(용량),
      컬럼명 자료형(용량),
      제약조건
   );

- 테이블 삭제
   DROP TABLE 테이블명;

- 테이블 수정
   ALTER TABLE 테이블명
      테이블명수정    RENAME TO 새로운테이블명;
      컬럼명수정      RENAME COLUMN 기존컬럼명 TO 변경할컬럼명;
      타입수정      MODIFY (기존컬럼명 자료형(용량));
      컬럼추가      ADD (새로운컬럼명 자료형(용량));
      컬럼삭제      DROP COLUMN 기존컬럼명;
      제약조건추가   ADD CONSTRAINT 제약조건이름 PRIMARY KEY(현재테이블의 컬럼명);
ADD CONSTRAINT 제약조건이름 FOREIGN KEY(현재테이블의 컬럼명) REFERENCES 상위테이블명(컬럼명);
      제약조건삭제   DROP CONSTRAINT 제약조건이름;

- 테이블 내용 전체 삭제
   TRUNCATE TABLE 테이블명;

1. 제약조건
1) PRIMARY KEY(PK)
	고유한 값이며 각 행의 구분점으로 사용된다
	중복이 없고 NULL값을 허용하지 않는다

2) FOREIGN KEY(FK)
	다른 테이블의 PK를 사용하며 중복이 가능하다
	보통 테이블끼리 관계를 맺을 때 사용한다
	NULL값을 허용하지만 좋은 상황은 아니다

3) UNIQUE KEY(UK)
	NULL은 허용하지만 중복을 허용하지 않는다

4) NOT NULL
	NULL을 허용하지 않는다

5) CHECK(컬럼명 IN (값1, 값2, ...))
	특정 컬럼에 특정값만 허용하고 싶을 때 사용하는 제약 조건
	원하는 특정값이 들어왔는지 체크한다

	특정값 목록 중 하나만 허용		CHECK(컬럼 IN ('값1', '값2', ...))
	값 직접 비교			CHECK(컬럼 = '값')
	복합조건				CHECK((조건1) OR/AND (조건2))
	여러 컬럼 동시 조건      CHECK((A='X' AND B='Y') OR (A='O' AND B = 'N'))
	
6) DEFAULT
	컬럼명 데이터타입 DEFAULT 기본값

	ALTER TABLE 테이블명
	MODIFY 컬럼명 DEFAULT 기본값;
	
7) 조합키(복합키)
	두 개 이상의 컬럼을 하나의 KEY로 지정하는것
	테이블에 한개의 PK만 존재할 수 있지만 조합키를 사용하면
 두 개 이상의 컬럼을 하나의 PK로 사용할 수 있다
	단일 컬럼으로는 보장할 수 없을때 조합키를 사용한다
	개별 컬럼에 중복값이 존재할 수 있다	


	
+) 제약조건 정의 방법
	- 컬럼 레벨에서의 정의 : 하나의 컬럼을 정의하면서 같이 정의
	- 테이블 레벨로 정의 : CREATE 쿼리 마지막에 정의
	- NOT NULL(컬럼레벨에서만 정의가능, 컬럼 옆에서만 작성가능)
		제약조건은 컬럼 레벨 정의만 가능
	- 제약조건명을 쓸 때는 테이블명_컬럼명_제약조건명 또는 시스템구분_테이블명_제약조건명

+) 데이터 베이스 명명 규칙(테이블, 컬럼명 작성시 주의사항)
	이름은 중복불가
	문자로 시작해야한다
	특수문자는 _, $, # 3가지만 사용가능!
	예약어는 사용불가
	공백 사용불가
	최대 30글자까지만 작성가능(어지간하면 30글자까지 안감)


2. 무결성
	데이터의 결함이 없다(데이터의 정확성, 일관성, 유효성이 유지되는것)	
	
1) 정확성	: 데이터는 애매하지 않아야한다
	제품 색상 : 보라색같기도 한 빨간색 < 이렇게 애매하면 X
	제품 색상 : 버건디(명확한 색상명을 사용한다!)
	
2) 일관성 : 각 사용자가 일관된 데이터를 볼 수 있도록 해야한다
	고객 테이블 : 홍길동	
	주문 테이블 : 길동 홍
	
	고객 테이블 : 홍길동
	주문 테이블 : 홍길동 (모든 테이블에서 같은 사용자는 동일한 형식으로 기록되어야한다!)
	
3) 유효성	 : 데이터가 실제로 존재하는 데이터여야한다 
		(데이터는 사실 기반이어야하며 거짓이나 가상의 값은 유효하지 않다)
	국가 : 대한민국1, 대한민국2
	결혼여부 : 미혼(실제 기혼)
			
	국가 : 대한민국
	결혼여부 : 기혼

3. 무결성의 3가지 종류
1) 개체무결성(Primary Key)
	모든 테이블이 PK로 설정된 컬럼을 가져야한다(모든 테이블에 무조건 PK가 존재해야한다)
	모든 행은 고유하게 식별되어야하며, PK값은 비워둘 수 없다
	중복값 불가능, NULL값 불가능

2) 참조무결성(Foreign Key)
	두 테이블의 데이터가 항상 일관된 값을 가지도록 유지하는 것을 의미한다
		(자식 테이블의 외래키는 부모 테이블의 기본키와 반드시 연결되어야한다)
	중복값 가능, NULL값 가능

3) 도메인 무결성(타입과 제약조건)
	컬럼의 타입, NULL값 허용등에 대한 사항을 정의하고 
		올바른 데이터가 입력되었는지를 확인하는것을 의미
	
	이메일 컬럼에 숫자값 1234, 성별 컬럼에 ABC (x)
	이메일 컬럼에 varchar2, 성별 컬럼에 M/F, 남/여 (o)

4. 모델링(기획) ★★★★★
	요구사항 분석 -> 개념적설계 -> 논리적설계 -> 물리적설계 -> 구현

1) 요구사항 분석
	회원, 상품, 주문 : 3가지를 관리하려고 한다
	- 이름, 주소, 핸드폰번호, 생일, 아이디, 비밀번호, 이메일주소, 상품번호, 상품명, 가격, 재고량, 회원번호, 상품번호, 아이디, 주문상태
	한명의 회원이 여러건의 주문을 할 수 있다
	한 상품이 여러 주문에 포함될 수 있다

2) 개념적 설계(개념모델링)
	회원		상품		주문
	이름		상품번호		주문날짜
	아이디		상품명		회원번호
	비밀번호		가격		상품번호
	주소		재고량		아이디
	생일				주문상태
	핸드폰번호

	- 관계를 맺을지, 독립적으로 유지될지 생각한다
	- 상위테이블, 하위테이블을 생각한다
	
	* 회원 1:N 주문	
	* 상품 1:N 주문	
	* 주문은 회원과 상품 사이의 다대다 관계를 해소한 중간엔티티
		
	회원은 회원정보만 있으면된다, 주문이나 상품정보를 넣을 필요가 없다
	상품은 상품정보만 있으면된다
	주문은 누가, 어떤것을 주문했는지 알아야한다(회원, 상품)

3) 논리적설계(논리모델링)
	회원			상품			주문
	회원번호(PK) 숫자		상품번호(PK) 숫자		주문날짜      날짜
	아이디(UK)   문자		상품명	   문자		상품번호(FK)  숫자
	비밀번호     문자		가격	   숫자		주문번호(PK)  숫자
	주소	   문자		재고량	   숫자		주문상태      문자
	생일	   문자					회원번호(FK)  숫자
	핸드폰번호(UK)문자				
	이름	   문자			

	PK로 사용할 것을 찾는다
	회원 PK : 회원번호
	    UK : 아이디, 핸드폰번호
	    NOT NULL : 비밀번호, 아이디, 핸드폰번호, 주소
	상품 PK : 상품번호
	    NOT NULL : 상품명, 가격, 재고량
	주문 PK : 주문번호
	    FK : 회원번호, 상품번호
	    NOT NULL : 주문날짜, 주문상태
	
4) 물리적 설계	
	회원			상품			주문
	회원번호(PK) 숫자		상품번호(PK) 숫자		주문날짜      날짜
	아이디(UK)   문자		상품명	   문자		상품번호(FK)  숫자
	비밀번호     문자		가격	   숫자		주문번호(PK)  숫자
	주소	   문자		재고량	   숫자		주문상태      문자
	생일	   문자					회원번호(FK)  숫자
	핸드폰번호(UK)문자				
	이름	   문자		

회원테이블(TBL_USER)
USER_NUMBER	NUMBER : PRIMARY KEY
-------------------------
USER_ID		VARCHAR2(100)
USER_PW		VARCHAR2(100)
USER_ADDRESS	VARCHAR2(100)
USER_BIRTH	DATE
USER_PHONE	VARCHAR2(14)
USER_NAME	VARCHAR2(10)

5) 구현
	물리적설계를 보면서 코드를 작성하면 된다	
----------------------------------------------------------------------------------
[모델링 해석1]
요구사항분석 -> 개념적설계(개념모델링) -> 논리적설계(논리모델링) -> 물리적설계(물리모델링) -> 구현

1. 요구사항 분석
	핸드폰과 핸드폰케이스를 판매한다
	핸드폰을 구매하면 핸드폰케이스도 같이 구매한다
	핸드폰은 제품번호, 색상, 사이즈, 가격, 제조일, 할인율
	핸드폰케이스는 제품번호, 색상, 가격
	핸드폰은 특정 케이스만 같이 구입할 수 있다
	
	- 핸드폰이 부모(상위) 테이블
	
2. 개념적설계(개념모델링)
	핸드폰		핸드폰케이스
	제품번호		제품번호
	색상		색상
	가격		가격
	사이즈
	제조일
	할인율

	- 핸드폰이 부모(상위) 테이블
	
3. 논리적설계(논리모델링)
	핸드폰		핸드폰케이스
	제품번호 PK	제품번호 PK
	색상		색상
	가격		가격
	사이즈		핸드폰제품번호 FK
	제조일
	할인율

	핸드폰 
	UK : X
	NOT NULL : 가격, 사이즈, 제조일, 색상
	DEFAULT : 가격, 사이즈, 제조일
	CHECK : 색상, 사이즈
	
	핸드폰케이스
	UK : X
	NOT NULL : 가격, 색상
	CHECK : 색상

4. 물리적설계(물리모델링)
	핸드폰			핸드폰케이스
	제품번호 PK 숫자		제품번호 PK	숫자
	색상	  문자		색상		문자
	가격	  숫자		가격		숫자
	사이즈	  숫자		핸드폰제품번호 FK	숫자
	제조일	  DATE
	할인율     숫자

핸드폰 테이블(TBL_PHONE)
PHONE_SERIAL_NUMBER	NUMBER : PRIMARY KEY
-----------------------------------------------
PHONE_COLOR		: VARCHAR2(100)
PHONE_PRICE		: VARCHAR2(100)
PHONE_SIZE		: NUMBER
PHONE_PRODUCTION_DATE	: DATE
PHONE_SALE		: NUMBER

핸드폰케이스 테이블(TBL_CASE)
CASE_SERIAL_NUMBER	NUMBER : PRIMARY KEY
--------------------------------------------------
CASE_COLOR : VARCHAR2(100)
CASE_PRICE : NUMBER
PHONE_SERIAL_NUMBER NUMBER : FOREGIN KEY

+) 모델링
	데이터베이스 시스템에서 데이터 구조와 관계를 설계하는 것을 의미

요구사항분석 : 비즈니스 관점에서 정리
	어떤 데이터를 관리할 것인지를 비즈니스 관점에서 정리
개념모델링 : 엔티티 도출이 목적
	현실세계에 존재하는 정보단위인 엔티티(Entity)를 사람이 이해할 수 있는 개념 세계의 정보구조로
		추상화하는 단계를 의미
논리모델링 : 데이터의 속성, 키, 엔티티들의 관계 정의
	개념 세계의 정보구조를 정보시스템이 이해할 수 있는 형태로 표현한 단계(실질적인 데이터 모델링에 해당함)
물리모델링 : 엔티티를 데이터베이스의 테이블로 구현, 테이블/키/제약조건 등을 정의
	정보시스템 세계의 논리적 구조를 정보시스템이 처리할 수 있는 형태로 구조화하는 단계
	구조화된 결과는 데이터 스키마로 표현됨
구현 : SQL문을 사용하여 테이블 생성 및 데이터 삽입

개념적설계				논리적설계				물리적설계
엔터티(Entity)			릴레이션(Relation)		테이블(Table)
릴레이션(Relation)		릴레이션(Relation)		컬럼(Column)
속성(Attribute)			속성(Attribute), 컬럼(Column)	행(Row)
주식별자(Main Identifier)		기본키(Primary Key)		기본키(PK, Primary Key)
외래식별자(Foreign Identifier)	외래키(Foreign Key)		외래키(FK, Foreign Key)
인스턴스(Instance)		튜플(Tuple), 행(Row)		
도메인(Domain)			도메인(Domain)			도메인(Domain)

+) 추가용어
릴레이션(Relation)	테이블과 같은 개념, 튜플과 속성의 집합
튜플(Tuple)		릴레이션의 한 행(row), 레코드 한개
속성(Attribute)		릴레이션의 한 열(column), 컬럼 한 개
도메인(Domain)		속성이 가질 수 있는 값의 범위
디그리(Degree)		릴레이션(테이블)의 속성(컬럼) 수
카디널리티(Cardinality)	릴레이션(테이블)의 튜플(행)의 수
인스턴스(Instance)	실제 릴레이션에 저장된 데이터(행)들의 집합

+) 키 종류
기본키(Primary Key)	각 튜플을 유일하게 식별할 수 있는 속성(들), 대표키
			중복불가, NULL 불가
후보키(Candidate Key)	기본키가 될 수 있는 후보들, 중복 불가, NULL 불가
			유일성과 최소성을 만족해야함, 하나 이상의 후보키가 존재할 수 있음
대체키(Alternate Key)	후보키 중에서 기본키로 선택되지 않은 키
			유일성과 최소성을 만족해야함
외래키(Foreign Key)	다른 릴레이션의 기본키를 참조하는 속성, 릴레이션 간 관계를 맺을 때 사용
슈퍼키(Super Key)		튜플을 유일하게 식별할 수 있는 모든 속성의 집합, 후보키보다 크거나 같음
			유일성만 만족해야함(최소성은 만족하지 않아도 됨)

유일성(Uniqueness)	릴레이션 내에서 키가 모든 튜플을 구분할 수 있어야함
			해당 속성에 대해 중복된 값이 없어야함
최소성(Minimality)	유일성을 만족하는 집합에서 불필요한 속성이 없어야함
			속성을 하나라도 제거하면 유일성이 깨지는 가장 작은 속성 집합이어야함

학생 테이블
학번(Student_ID)	이름(Student_name)	이메일(Email)
20250611	짱구			gu@gmail.com	
20250612	철수			su@gmail.com
20250613	유리			yuri@gmail.com

- 학번과 이메일은 유일한 값을 가짐 => 유일성O
- 이름은 중복될 수 있음 => 유일성X
- 학생	유일성O, 최소성  => 후보키
- 이름	유일성X, 최소성O => X
- 이메일	유일성O, 최소성O => 후보키
- 학번, 이메일 유일성O, 최소성X(학번하나만으로도 가능)	=> 슈퍼키

+) 무결성(Integrity)
	데이터의 정확성, 일관성, 유효성 유지
	
개체무결성		각 테이블에 고유 식별자(PK) 필요
참조무결성		FK는 존재하는 PK만 참조가능
도메인무결성	데이터 타입, NULL, CHECK등을 통한 값 제한

5. 정규화(Normalization)
	DDL, DML 개념이 있어야한다
	테이블에 컬럼을 무엇을 넣어야할 지, 하나의 테이블을 두개로 분리할 지 고민하는 작업

	무결성의 특징	일관성, 유일성, 정확성을 지켜도 정규화를 하지 않으면 
						나중에 테이블간 문제가 발생할 수 있다
	1차~6차 정규화까지 분리하여 진행한다 보통은 3차까지만 진행을 한다

1) 데이터베이스에서 정규화가 필요한 이유
	데이터베이스를 잘못 설계하면 불필요한 데이터 중복으로 인해 공간이 낭비된다
	이러한 현상을 이상(Anomaly) 현상이라고 한다

- 이상현상 : 데이터 베이스 설계가 잘못되어 발생하는 문제
	
	

[모델링 과제]
1. 요구사항 분석
	도서관에서 회원의 정보와 책의 정보가 필요하다
	회원의 정보는 회원번호, 이름, 나이, 핸드폰번호, 주소가 필요하고 책의 정보는 도서번호, 책이름, 장르가 필요하다
	장르는 인문학, IT, 추리 3개뿐이다
	한명의 회원은 여러권의 책을 빌릴 수 있따
2. 개념적 설계

3. 논리적 설계

4. 물리적 설계

5. 구현
	테이블 생성 후 5개씩 값 넣고 조회하기
	1) 인문학 장르의 책이 몇 권인지 조회(컬럼은 모두 조회)
	2) 회원 테이블 조회(회원번호 위에서 3명만 조회)