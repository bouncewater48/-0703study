day20_작업물 (dbms 2일차)
복습 -> sql문 주요 특징 -> SELECT -> 자료형 -> 연산자 -> SQL 쿼리문의 종류 -> DDL -> 무결성

-- 1번 : SELECT
-- 해석할때는 항상 FROM이 첫번째, SELECT는 그 이후
-- SELECT 컬럼명 FROM 테이블명;
-- 해당 테이블에서 특정 컬럼을 선택해서 조회하겠다는 의미
-- 컬럼명 자리에 *를 쓰면 모든 컬럼 선택을 의미
SELECT * FROM EMPLOYEES;
-- 해석 : EMPLOYEES 테이블에서 모든 컬럼을 조회하겠다

-- HR.테이블명 작성하는 이유는 여러 계정의 같은 이름의 테이블이름이 존재할 수 있기 때문이다
-- 지금 로그인한 게정의 테이블의 우선순위가 높기 때문에 일반적으로 계정명은 생략이 가능하다
SELECT FIRST_NAME FROM EMPLOYEES;
SELECT FIRST_NAME FROM HR.EMPLOYEES;
-- 해석 : HR 계정에 있는 employees 테이블에서 first_name 컬럼을 조회하겠다

-- 두 개의 결과는 다르다(select 뒤에 작성된 컬럼명대로 Result 테이블에 표시된다)
-- 컬럼 조회시 순서가 중요하다(결과가 다르게 나옴!!)
SELECT first_name, last_name
FROM employees;

SELECT last_name, first_name
FROM employees;
-- 해석 : employees 테이블에서 LAST_NAME, FIRST_NAME 컬럼을 조회하겠다

-- 정렬해서 조회하기
-- SELECT 컬럼명 FROM 테이블명 ORDER BY 컬럼명 [ASC or DESC];

-- employees 테이블에서 사원의 이름(FIRST_NAME), 성(LAST_NAME), 급여를 급여 낮은 순서부터 조회하기
-- 급여 낮은(오름차순) 순서부터 조회하기
SELECT * FROM employees;

SELECT FIRST_NAME, LAST_NAME, SALARY -- 2) FIRST_NAME, LAST_NAME, SALARY 컬럼을 조회할거야
FROM EMPLOYEES		-- 1)EMPLOYEES 테이블에서 
ORDER BY SALARY ASC; -- 3) SALARY 컬럼을 오름차순으로 정렬해서
-- ORDER BY에 ASC나 DESC를 쓰지 않으면 기본 오름차순(ASC) 정렬
-- 오름차순 정렬 ASC(Ascending) : 앞글자 3글자만 따서 ASC로 사용한다
-- 내림차순 정렬 DESC(Descending) : 앞글자 4글자만 따서 DESC로 사용한다

SELECT first_name, last_name, salary -- 2) first_name, last_name, salary 컬럼을 조회할거야
FROM EMPLOYEES -- 1) EMPLOYEES 테이블에서
ORDER BY salary DESC; -- 3) salary 컬럼을 내림차순으로 정렬해서

SELECT * FROM employees;
-- 문자의 정렬 (first_name) : ASC로 정렬 시 a -> z까지 순서대로 정렬, DESC로 정렬 시 z -> a까지 순서대로 정렬
SELECT first_name
FROM employees
ORDER BY first_name ASC;

-- 날짜의 정렬(hire_date) : ASC로 정렬시 예전날짜부터 최신날짜 순으로 정렬, DESC로 정렬시 최신날짜부터 과거날짜순으로 정렬
SELECT hire_date
FROM EMPLOYEES
ORDER BY hire_date ASC;

-- ORDER BY절의 컬럼명은 조회하는 컬럼명과 반드시 일치하지 않아도 가능하다
-- 해당 테이블에 있는 컬럼이라면 다른 컬럼명으로 정렬해도 무방하다
SELECT * FROM EMPLOYEES;

-- 조회할 컬럼 : EMPLOYEE_ID, 정렬할 컬럼 : SALARY
SELECT EMPLOYEE_ID  -- 2) EMPLOYEE_ID 컬럼을 조회하겠다
FROM EMPLOYEES      -- 1) EMPLOYEES 테이블에서
ORDER BY salary ASC;-- 3) SALARY 컬럼의 오름차순 정렬로

SELECT EMPLOYEE_ID, SALARY -- 2) EMPLOYEE_ID와 SALARY 컬럼을 조회하겠다
FROM EMPLOYEES		-- 1) EMPLOYEES 테이블에서
ORDER BY SALARY ASC;-- 3) SALARY 컬럼의 오름차순 정렬로

-- 2개의 정렬기준
-- 첫번째 작성한 컬럼의 값을 기준으로 잡아 정렬하고 해당 컬럼의 값이 동일하다면 
-- 2차적으로 그 다음 컬럼값을 기준으로 정렬한다

-- employees 테이블에서 first_name, salary, job_id 컬럼 조회하는데 
-- salary를 기준으로 내림차순정렬, first_name을 기준으로 오름차순정렬
SELECT first_name, salary, JOB_ID 
FROM employees
 ORDER BY salary DESC, FIRST_name ASC;
--ORDER BY salary DESC
-- 문자일때 3개이상의 컬럼이 있을 경우, 내림차순 또는 오름차순 정렬이 정확히 안됨
-- 따라서 정렬문을 하나 더 넣어서 정렬해주는것이 좋음

-- 사원테이블에서 직무ID조회
SELECT JOB_ID
FROM EMPLOYEES;

-- 직무의 종류를 확인하기 위해 중복 행 제거
-- DISTINCT : 해당 컬럼의 중복되는 값을 제외시킨다
-- SELECT [DISTINCT] 컬럼명 
-- FROM 테이블명 
-- ORDER BY 정렬할컬럼명 [ASC or DESC];

SELECT DISTINCT JOB_ID -- 2) job_id 컬럼을 중복 제거하고 조회할거다
FROM employees; 	   -- 1) employees 테이블에서
-- 결과 19행

-- 컬럼을 여러개 넣으면 DISTINCT는 어떻게 작동할까?
-- 여러 컬럼을 동시에 작성할 경우에는 2개의 컬럼이 모두 중복되는 경우에만 중복을 제거한다
SELECT DISTINCT JOB_ID, HIRE_DATE
FROM EMPLOYEES;
-- 105행

-- 별칭 붙여 조회하기
SELECT FIRST_NAME AS "이름"
FROM EMPLOYEES;

SELECT FIRST_NAME AS "이름", LAST_NAME AS "성", EMPLOYEE_ID AS "사원 번호"
FROM EMPLOYEES;

-- AS 키워드 생략 가능
-- "" 생략 가능 (단, 별칭에 띄워쓰기가 포함되어있으면 ""는 생략 불가능)
SELECT first_name "이름", last_name 성, employee_id
FROM employees;

-- 사원의 이름, 성, 봉급을 조회하는데 봉급 내림차순으로 별칭사용하여 조회하기
-- 쿼리문 작성시 순서		1)SELECT에서 조회할 컬럼 생각 -> 별칭 부여 2) FROM 테이블 생각 3)ORDER BY 정렬 생각
-- 쿼리문 실행 순서 		FROM -> SELECT -> ORDER BY
SELECT first_name "이름", last_name AS 성, salary AS "봉급" 
-- 2) first_name 컬럼은 이름이라는 별칭으로, 
-- last_name 컬럼은 성이라는 별칭으로, 
-- salary 컬럼은 봉급이라는 별칭으로 조회할거야
FROM employees         -- 1) employees 테이블에서
ORDER BY 봉급 DESC;  -- 3) 봉급 컬럼의 내림차순 정렬해서
--ORDER BY salary DESC;  -- 3) salary 컬럼의 내림차순 정렬해서

-- 1번 : SELECT

=====================================================================================


-- 2번 : 연산자
-- 피연산자 자리에 어떤 타입의 값이 오는지 
-- 연산자가 어떻게 동작하는지
-- 연산의 결과가 어떤 타입의 값인지 아는것 < 이 3가지 꼭 생각하기

-- 자료형 ; 문자형(CHAR, VARCHAR2), 숫자형(NUMBER), 날짜(DATE, TIMESTAMP)

-- (1) 연결연산자
-- a || b : a와 b를 연결해준다
-- dual 테이블 : 다른 테이블을 참조할 필요없이 값을 
-- 확인하고 싶을 때 사용할 수 있는 오라클의 기본 테이블

SELECT 10, 20, 10 || 20
FROM dual;

SELECT 'a',
	'b',
	'a' || 'b'
FROM dual;

-- employees 테이블에서 이름과 성을 연결해서 이름이라는 별칭으로 조회
SELECT  first_name || ' ' || last_name 이름
-- first_name과 last_name에 공백을 연결하겠다
FROM employees;

-- 날짜타입의 값 확인 => 결과는 문자자료형으로 나온다
--	타입에 상관없이 연결연산자 사용시 문자열로 바뀜
SELECT 	
--	hire_date || 1
	hire_date || 'a'
FROM
	employees;

/*실습
 * 사원의 이름과 메일주소를 출력
 * 이 때 이름은 이름과 성이 띄워쓰기로 이어져서 이름이라는 컬럼명으로 있고
 * 메일주소는 사원메일주소@koreait.com으로 메일 주소 라는 컬럼명이 있다
 */

-- select 컬럼명 first_name || ' ' || last_name 이름
--			email || '@koreait.com' "메일 주소"
-- from employees

SELECT first_name||' '||last_name 이름, 
		email || '@koreait.com' "메일 주소"
-- 2) forst_name과 last_name을 연결해서 이름이라는 별칭, 
--		email에 koreait.com 연결해서 조회하겠다
FROM employees; -- 1) employees 테이블에서

-- (2) 산술연산자
-- 숫자타입 산술연산의 결과 => 숫자타입

SELECT  employee_id, employee_id + 10, employee_id - 10,
	employee_id * 10, employee_id / 10
FROM employees;

-- 날짜 타입과 산술연산
-- 날짜와 숫자 => 결과는 날짜 타입(~일 후, ~일 전 으로 나온다)
SELECT hire_date,
	hire_date + 10, 
	HIRE_DATE - 10
FROM employees;

-- 날짜와 날짜
SELECT sysdate
FROM dual;

-- 날짜 - 날짜 => 몇일이 지났는지 결과로 나온다(숫자 타입)(D-Day)
SELECT hire_date,
	sysdate,
	sysdate - hire_date
FROM employees;

SELECT sysdate,-- 날짜 - 날짜만 가능, 결과는 숫자 타입으로 나온다
	to_date('2025-12-24', 'YYYY-MM-DD'),
	to_date('2025-12-24', 'YYYY-MM-DD') - sysdate
--	'2025-12-24' - sysdate : 문자 - 날짜 데이터타입은 뺄셈 불가!
FROM dual;

-- 날짜 + 날짜 => 오류 발생
-- 날짜와 숫자의 연산에서 기본적으로 숫자는 일 수를 의미하기 때문에 시간, 분 단위로
-- 연산하고 싶다면 일(24h)로 환산해야한다

SELECT sysdate,
	sysdate + 0.5,
	sysdate - 0.5
	-- 12/24	-- 12시간
	-- 1/24		-- 1시간
	-- 30/60/24	-- 30분
FROM dual;

SELECT 
	sysdate "현재시간",
	sysdate - 0.5 "12시간 전",
	sysdate + 0.5 "12시간 후",
	sysdate + 1/24 "1시간 후",
	sysdate + 30/60/24 "30분 후"
FROM dual;

-- 2번 : 연산자

=====================================================================================



=====================================================================================

-- 3번 : 연산자2
-- (3) 관계연산자 (비교연산자)
/*
SELECT [DISTINCT] 컬럼명 [AS "별칭"]
FROM 테이블명
WHERE 조건식
ORDER BY 정렬할컬럼명 [ASC or DESC]
*/

-- 행을 고르기 위해서 WHERE 절을 사용한다
-- 직원의 이름, 성, 급여를 조회한다
SELECT first_name 이름, last_name 성, salary 급여	-- 3) 각 컬럼에 별칭을 붙여서 조회한다
FROM employees									-- 1) employees 테이블에서
WHERE salary >= 10000							-- 2) salary가 10000보다 크거나 같은 값이 있는 행만 찾는다
ORDER BY 급여;									-- 4) 급여의 오름차순 정렬
-- WHERE 급여 >= 10000;	별칭 사용 불가능(별칭은 select에서 만들어지나, where은 select보다 앞에서 읽힌다)
-- 19행
-- from -> where -> select -> order by

SELECT * FROM  employees;

-- 이름이 David인 사람의 이름과 급여만 조회하기
SELECT first_name, salary
FROM employees
WHERE first_name = 'David';
-- SQL은 기본적으로 대소문자를 구분하지 않지만 값(데이터)으로 들어갈 때는 대소문자를 구분한다!!

-- (4) 논리 연산자 (AND, OR, NOT)
-- 피연산자 자리에 조건이 온다
-- 여러개의 조건을 연결할 때 사용한다

-- employees 테이블에서 부서가 영업부서(80)이면서 급여가 10000 이상인 직원들의
-- 이름, 성, 급여, 부서ID를 급여 오름차순으로 조회
SELECT first_name 이름, last_name 성, salary 급여, department_id 부서ID
FROM EMPLOYEES
WHERE department_id = 80 AND salary >= 10000
ORDER BY salary;


/*
employees 테이블에서 직원의 이름이 Peter인 사람 중에
급여가 5000 이상인 직원들만 email 내림차순으로 조회
칼럼 전체 조회
*/

SELECT *
FROM EMPLOYEES
WHERE salary >= 5000 AND FIRST_NAME = 'Peter'
ORDER BY email DESC;

-- 테이블 : employees
-- 조건1 : first_name = 'Peter'
-- 조건2 : salary >= 5000
-- 정렬 기준 : email DESC
SELECT *
FROM EMPLOYEES
WHERE first_name = 'Peter' AND salary >= 5000
ORDER BY email DESC;

/*
실습 1 : 급여가 5000 이상이고 직무ID가 SA_MAN인 직원 조회
	직원의 이름과 성은 이름이라는 별칭으로 연결해서 출력하되 급여기준으로 오름차순 정렬되도록
	
실습 2 : 부서ID가 60이거나 급여가 4000 이하인 직원 조회
	직원의 이름, 전화번호, 입사일을 출력하되 입사일 기준으로 내림차순 정렬되도록
	
실습 3 : manager_id가 존재하지 않는 직원들을 조회
	직원의 이름과 성은 직원명이라는 별칭으로 연결해서 출력

*/

-- 실습 1. 급여가 5000 이상이고 직무ID가 SA_MAN인 직원 조회
--	직원의 이름과 성은 이름이라는 별칭으로 연결해서 출력하되 급여기준으로 오름차순 정렬되도록
-- 테이블 : salary, departmentID
-- 실습버전
SELECT first_name, last_name 이름, job_id, salary -- 연결해야하는데 last_name만 이름으로 별칭 작성했음
FROM employees
WHERE JOB_ID = 'SA_MAN' AND salary >= 5000  
ORDER BY salary;

-- 강사님 버전
-- 조건 1 : 급여 >= 5000이상
-- 조건 2 : 직무ID = 'SA_MAN'
-- AND연산자 사용

SELECT first_name||' '|| last_name 이름
FROM employees
WHERE salary >= 5000 AND JOB_ID = 'SA_MAN'
ORDER BY salary ASC;

-- 실습 2 : 부서ID가 60이거나 급여가 4000 이하인 직원 조회
--	직원의 이름, 전화번호, 입사일을 출력하되 입사일 기준으로 내림차순 정렬되도록
-- 실습버전
SELECT first_name, Phone_number, hire_date, salary, DEPARTMENT_ID --DEPARTMENT_ID는 where절에만 작성하면 됨
FROM employees
WHERE DEPARTMENT_ID = 60 OR SALARY <= 4000
ORDER BY hire_date DESC;
-- 강사님 버전
SELECT first_name, PHONE_NUMBER, hire_date
FROM employees;
WHERE DEPARTMENT_ID = 60 OR SALARY <= 4000
ORDER BY hire_date DESC;

--실습 3 : manager_id가 존재하지 않는 직원들을 조회
--	직원의 이름과 성은 직원명이라는 별칭으로 연결해서 출력
-- 실습버전
--SELECT first_name, last_name 직원명, MANAGER_ID 
--SELECT first_name||' '||last_name 직원명, MANAGER_ID 
SELECT *
FROM employees
WHERE manager_id = NULL; -- IS NULL을 쓰면 해결!
--WHERE manager_id = 'NULL';
--WHERE manager_id = "NULL";
--WHERE CHAR(4) manager_id = 'NULL';
--WHERE CHAR(4) manager_id = "NULL"
--ORDER BY MANAGER_ID;

-- 강사님 버전
SELECT * FROM employees;

-- NULL : 값이 없음을 나타내는 값
-- NULL은 관계연산자로 연산이 불가능하다
-- NULL 연산자를 사용한다 IS NULL, IS NOT NULL
SELECT first_name ||' '|| last_name 직원명
FROM employees
WHERE manager_id IS NULL;

-- (5) SQL 연산자
-- BETWEEN a AND b : a이상 b이하인 조건 => 범위 내에 포함되면 참

-- employees 테이블에서 salary가 10000이상 12000이하인 직원의
-- first_name, last_name, salary를 salary 오름차순으로 조회

SELECT first_name,
	last_name,
	salary
FROM employees
WHERE salary BETWEEN 10000 AND 12000
ORDER BY salary;
-- 결과 : 11행


-- IN(a, b, c) : a 혹은 b 혹은 c 인 조건 => a, b, c 하나라도 포함되면 참

SELECT first_name, last_name, salary
FROM employees
WHERE salary IN(10000, 11000, 12000)
ORDER BY SALARY;
-- 결과 : 8행

-- LIKE : 문자조건, 패턴을 만들 때 사용한다
-- % : ~아무거나 / _ : 자리수
SELECT first_name FROM employees;

SELECT first_name
FROM employees
--WHERE first_name LIKE '%n'; -- first_name이 n으로 끝나는 직원 조회
--WHERE first_name LIKE 'K%'; -- first_name이 k로 시작하는 직원 조회
--WHERE first_name LIKE '%en%'; -- first_name에 en이 포함되는 직원 조회
--WHERE first_name LIKE '%e%n%'; -- first_name에 e와 n을 포함하는 직원 조회
--WHERE first_name LIKE '%e_n%'; -- first_name에 e와 n 사이에 한글자 이상이 더 있는 직원 조회
WHERE first_name LIKE '____e'; -- first_name에 다섯글자면서 e로 끝나는 직원 조회

-- NULL : 데이터가 없음을 나타내는 값
-- NULL은 연산하면 결과가 무조건 NULL이다
SELECT NULL + 10, NULL - 10, NULL * 10, NULL / 10
FROM dual;


=====================================================================================

-- 4번 : 연산자 실습

/*	모든 이름은 이름과 성을 띄워쓰기 포함하여 연결
 * 
 *[연습] 모든 직원의 이름, 급여, 연봉이라는 이름으로 출력하기
 */
SELECT * FROM employees;
SELECT first_name ||' '|| last_name 이름,
	salary 급여,
	salary * 12 연봉
FROM employees;

/*
	따로 컬럼명이 명시가 안될 경우 조회할 컬럼명 : 직원번호, 이름, 급여, 입사일

1. 모든 직원의 이름, 급여, 커미션, 커미션을 포함한 연봉을 총 보상이라는 이름으로 출력
단, 커미션이 NULL인 경우 0으로 처리할 것

2. 직원번호와 이메일을 연결해서 직원번호_이메일이라는 별칭으로 출력
조회할 컬럼명 : 직원번호, 이메일, 급여

3. 급여가 7000 초과인 직원의 이름과 급여 출력하기

4. 부서번호가 50 또는 80번이 아닌 직원들만 출력하기

5. 급여가 4000이상 7500이하인 직원을 조회하기
조회할 컬럼명 : 직원번호, 이름, 급여, 입사일

6. 직무ID가 IT_PROG, SA_REP, SA_MAN인 직원만 조회하기

7. 커미션을 받는 직원만 조회하기

8. 이름에 D와 e가 포함되는 직원들만 조회하기

9. 직무ID가 IT_PROG가 아닌 직원만 조회하기
*/

--1. 모든 직원의 이름, 급여, 커미션, 커미션을 포함한 연봉을 
--   총 보상이라는 이름으로 출력
--단, 커미션이 NULL인 경우 0으로 처리할 것
--SELECT *
SELECT first_name ||' '||last_name 이름, salary 급여, 
COMMISSION_PCT 커미션, NVL(commission_pct, 0) "커미션 비율",
salary * 12 총보상
FROM employees;


SELECT 
first_name ||' '||last_name 이름,
salary 급여,
COMMISSION_PCT 커미션,
salary * 12 * NVL2(commission_pct, commission_pct, 0) "총보상"
FROM employees;

--NVL2(커미션, 커미션, 0) : 커미션_PCT가 NULL이 아니면 그 값을 반환, NULL이면 0을 반환

-- 커미션이 전체 연봉 대비
-- 월마다 대비 총보상 = 월급 * 12 + (월급 * 커미션 비율 * 12)
-- 커미션은 매달 받는 비율(%) 연봉에 포함되어야한다
-- salary 월급(급여)
-- 기본 연봉 : salary * 12
-- 커미션도 매달 나온다 : salary * commission_pct * 12

SELECT 
first_name ||' '||last_name 이름,
salary 급여,
COMMISSION_PCT 커미션,
salary * 12 + NVL2(salary * commission_pct * 12, commission_pct, 0) "총보상"
FROM employees;

-- 2. 직원번호와 이메일을 연결해서 직원번호_이메일이라는 별칭으로 출력
-- 조회할 컬럼명 : 직원번호, 이메일, 급여
SELECT employee_id 직원번호,employee_id || '_' ||email 직원번호_이메일, 
salary 급여
FROM employees;

--3. 급여가 7000 초과인 직원의 이름과 급여 출력하기
SELECT first_name ||' '||last_name 이름, SALARY 급여, EMPLOYEE_ID 직원번호,HIRE_DATE 입사일
FROM employees
WHERE salary > 7000
ORDER BY salary;

--4. 부서번호가 50 또는 80번이 아닌 직원들만 출력하기
SELECT DEPARTMENT_ID 부서번호,first_name ||' '||last_name 이름, 
salary 급여, employee_id 직원번호, hire_date 입사일 
FROM employees
WHERE DEPARTMENT_ID != 50 AND DEPARTMENT_ID != 80
--WHERE DEPARTMENT_ID != 50 or DEPARTMENT_ID != 80
ORDER BY DEPARTMENT_ID;

--5. 급여가 4000이상 7500이하인 직원을 조회하기
--조회할 컬럼명 : 직원번호, 이름, 급여, 입사일
SELECT first_name ||' '||last_name 이름, SALARY 급여, EMPLOYEE_ID 직원번호,HIRE_DATE 입사일
FROM employees
--WHERE salary >= 4000 AND salary <= 7500
WHERE salary BETWEEN 4000 AND 7500
ORDER BY salary; -- 올림차순 필요없으나 보기 편해짐

--6. 직무ID가 IT_PROG, SA_REP, SA_MAN인 직원만 조회하기
SELECT first_name 이름, SALARY 급여, 
EMPLOYEE_ID 직원번호,HIRE_DATE 입사일, job_id 직무ID
FROM employees
--WHERE JOB_ID = 'IT_PROG' or 'JOB_ID' = 'SA_REP' or JOB_ID = 'SA_MAN'
WHERE JOB_ID IN('IT_PROG', 'SA_REP', 'SA_MAN');
--ORDER BY JOB_ID;

--7. 커미션을 받는 직원만 조회하기
SELECT first_name ||' '||last_name 이름, SALARY 급여, 
EMPLOYEE_ID 직원번호,HIRE_DATE 입사일, COMMISSION_PCT 커미션
FROM employees
WHERE COMMISSION_PCT IS NOT NULL;

--8. 이름에 D와 e가 포함되는 직원들만 조회하기
SELECT first_name ||' '||last_name 이름, salary 급여,
EMPLOYEE_ID 직원번호,HIRE_DATE 입사일
FROM employees
--WHERE first_name ||' '|| last_name LIKE '%D%e%';
WHERE first_name LIKE '%D%' AND last_name LIKE '%e%';

--9. 직무ID가 IT_PROG가 아닌 직원만 조회하기
SELECT first_name ||' '||last_name 이름, salary 급여,
EMPLOYEE_ID 직원번호,HIRE_DATE 입사일, job_id 직무ID
FROM employees
WHERE JOB_ID != 'IT_PROG';

=====================================================================================

-- 5번 : DML 기초

-- 테이블 생성(DDL)
CREATE TABLE TBL_MEMBER(
	MEMBER_ID NUMBER,
	MEMBER_NAME VARCHAR2(100),
	MEMBER_AGE NUMBER(3)
);

-- 데이터 추가
/*INSERT INTO 테이블명
 * VALUES (값1, 값2, 값3);*/
INSERT INTO TBL_MEMBER
VALUES (1, '강승훈', 27);

INSERT INTO TBL_MEMBER (MEMBER_ID, MEMBER_NAME)
VALUES (2, '홍길동');


INSERT INTO TBL_MEMBER
VALUES (3, '짱구', NULL);

-- 데이터 조회
SELECT * FROM TBL_MEMBER;

SELECT *
FROM TBL_MEMBER
WHERE MEMBER_NAME = '홍길동';

-- 데이터 삭제
--DELETE FROM 테이블명
DELETE FROM TBL_MEMBER
WHERE MEMBER_NAME = '홍길동';

SELECT * FROM TBL_MEMBER;

INSERT INTO TBL_MEMBER 
VALUES (4, '철수', 5);

INSERT INTO TBL_MEMBER 
VALUES (5, '유리', 5);

INSERT INTO TBL_MEMBER 
VALUES (6, '훈이', 5);

-- 수정
--UPDATE 테이블명 SET 컬럼명 = 값
--WHERE 조건식

UPDATE TBL_MEMBER 
SET MEMBER_AGE = 5;

SELECT * FROM TBL_MEMBER;

-- MEMBER_ID가 1인 값을 27으로 변경
UPDATE TBL_MEMBER
SET MEMBER_AGE = 27
WHERE MEMBER_ID = 1;

-- 두번째 테이블 생성(TBL_STUDENT)
CREATE TABLE TBL_STUDENT(
	STUDENT_NUMBER NUMBER,
	STUDENT_NAME VARCHAR2(100),
	STUDENT_MATH NUMBER,
	STUDENT_ENG NUMBER,
	STUDENT_KOR NUMBER,
	STUDENT_GRADE VARCHAR2(100)
);

-- 테이블 완전 삭제
DROP TABLE TBL_STUDENT;
--DROP : 테이블이 완전히 사라짐, 절대 함부로 누르지 말것

SELECT * FROM TBL_STUDENT;

/* 학생 테이블에 데이터 추가
 * 학생번호 이름 수학 영어 국어
 * 1      짱구 90 90 90
 * 2      유리 70 25 55
 * 3      맹구 40 100 70
 * 4      훈이 100 15 20
 * */

INSERT INTO TBL_STUDENT 
VALUES(0, '김철수', 100, 100, 100, 'A+');

INSERT INTO TBL_STUDENT(STUDENT_NUMBER, STUDENT_NAME, 
STUDENT_MATH, STUDENT_ENG, STUDENT_KOR)
--VALUES (1, '짱구', 90, 90, 90);
--VALUES (2, '유리', 70, 25, 55);
--VALUES (3, '맹구', 40, 100, 70);
VALUES (4, '훈이', 100, 15, 20);

SELECT * FROM TBL_STUDENT;

=====================================================================================



=====================================================================================















































































